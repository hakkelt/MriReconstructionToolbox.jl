<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulation Tools · MriReconstructionToolbox.jl</title><meta name="title" content="Simulation Tools · MriReconstructionToolbox.jl"/><meta property="og:title" content="Simulation Tools · MriReconstructionToolbox.jl"/><meta property="twitter:title" content="Simulation Tools · MriReconstructionToolbox.jl"/><meta name="description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="og:description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="twitter:description" content="Documentation for MriReconstructionToolbox.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MriReconstructionToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../theory/">Theoretical Background</a></li><li><span class="tocitem">High-level Interface</span><ul><li><a class="tocitem" href="../acquisition_info/">AcquisitionInfo</a></li><li class="is-active"><a class="tocitem" href>Simulation Tools</a><ul class="internal"><li><a class="tocitem" href="#Why-Simulate?"><span>Why Simulate?</span></a></li><li><a class="tocitem" href="#Overview:-Complete-Simulation-Pipeline"><span>Overview: Complete Simulation Pipeline</span></a></li><li><a class="tocitem" href="#Phantoms"><span>Phantoms</span></a></li><li><a class="tocitem" href="#Coil-Sensitivity-Maps"><span>Coil Sensitivity Maps</span></a></li><li><a class="tocitem" href="#Subsampling-Patterns"><span>Subsampling Patterns</span></a></li><li><a class="tocitem" href="#Simulate-Acquisition"><span>Simulate Acquisition</span></a></li><li><a class="tocitem" href="#Advanced-Simulation"><span>Advanced Simulation</span></a></li></ul></li><li><a class="tocitem" href="../reconstruction/">Reconstruction</a></li><li><a class="tocitem" href="../regularization/">Regularization</a></li><li><a class="tocitem" href="../algorithms/">Optimization Algorithms</a></li><li><a class="tocitem" href="../nameddims/">Named Dimensions</a></li><li><a class="tocitem" href="../decomposition/">Problem Decomposition</a></li></ul></li><li><span class="tocitem">Low-Level Interface</span><ul><li><a class="tocitem" href="../../low-level/operators/">MRI Operators</a></li><li><a class="tocitem" href="../../low-level/custom_reconstruction/">Custom Reconstruction</a></li><li><a class="tocitem" href="../../low-level/abstract_operators/">AbstractOperators.jl</a></li><li><a class="tocitem" href="../../low-level/proximal_operators/">ProximalOperators.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">High-level Interface</a></li><li class="is-active"><a href>Simulation Tools</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simulation Tools</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/master/docs/src/high-level/simulation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulation-Tools"><a class="docs-heading-anchor" href="#Simulation-Tools">Simulation Tools</a><a id="Simulation-Tools-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Tools" title="Permalink"></a></h1><p>MriReconstructionToolbox provides comprehensive tools for simulating MRI acquisitions. These are essential for testing reconstruction algorithms, teaching MRI concepts, and prototyping new acquisition strategies.</p><h2 id="Why-Simulate?"><a class="docs-heading-anchor" href="#Why-Simulate?">Why Simulate?</a><a id="Why-Simulate?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Simulate?" title="Permalink"></a></h2><p>Simulation is useful for:</p><ul><li><strong>Testing reconstruction algorithms</strong> without needing real MRI data</li><li><strong>Understanding MRI physics</strong> through hands-on experimentation</li><li><strong>Prototyping new acquisition strategies</strong> before scanner implementation</li><li><strong>Teaching and learning</strong> MRI concepts interactively</li><li><strong>Benchmarking</strong> reconstruction methods with known ground truth</li></ul><h2 id="Overview:-Complete-Simulation-Pipeline"><a class="docs-heading-anchor" href="#Overview:-Complete-Simulation-Pipeline">Overview: Complete Simulation Pipeline</a><a id="Overview:-Complete-Simulation-Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Overview:-Complete-Simulation-Pipeline" title="Permalink"></a></h2><p>A typical simulation workflow:</p><pre><code class="language-julia hljs">using MriReconstructionToolbox

# 1. Create a phantom (ground truth image)
img = shepp_logan(256, 256)

# 2. Generate coil sensitivity maps
smaps = coil_sensitivities(256, 256, 8)

# 3. Create a subsampling pattern
pdf = VariableDensitySampling(PolynomialDistribution(3), 3.0, 0.1)
pattern = create_sampling_pattern(pdf, (256, 256))

# 4. Simulate the acquisition
acq = AcquisitionInfo(is3D=false,
                      sensitivity_maps=smaps,
                      subsampling=pattern)
acq_with_data = simulate_acquisition(img, acq)

# 5. Reconstruct and compare
img_recon = reconstruct(acq_with_data, L1Wavelet2D(5e-3), verbose=false)</code></pre><h2 id="Phantoms"><a class="docs-heading-anchor" href="#Phantoms">Phantoms</a><a id="Phantoms-1"></a><a class="docs-heading-anchor-permalink" href="#Phantoms" title="Permalink"></a></h2><p>Phantoms are synthetic images that serve as ground truth for testing.</p><h3 id="Shepp-Logan-Phantom"><a class="docs-heading-anchor" href="#Shepp-Logan-Phantom">Shepp-Logan Phantom</a><a id="Shepp-Logan-Phantom-1"></a><a class="docs-heading-anchor-permalink" href="#Shepp-Logan-Phantom" title="Permalink"></a></h3><p>The classic test phantom for MRI reconstruction.</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.shepp_logan"><a class="docstring-binding" href="#MriReconstructionToolbox.shepp_logan"><code>MriReconstructionToolbox.shepp_logan</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">shepp_logan(nx::Int, ny::Int; oversample=3) -&gt; Array{ComplexF32, 2}
shepp_logan(nx::Int, ny::Int, nz::Int; oversample=3) -&gt; Array{ComplexF32, 3}</code></pre><p>Generate a Shepp-Logan phantom for MRI simulation and reconstruction testing.</p><p>The Shepp-Logan phantom is a standard test image widely used in medical imaging research, particularly for MRI and CT reconstruction algorithm validation. This implementation uses the Toft modification of the original Shepp-Logan phantom, which provides better contrast for modern reconstruction algorithms.</p><p><strong>Arguments</strong></p><ul><li><code>nx::Int</code>: Number of pixels/voxels in the x-dimension</li><li><code>ny::Int</code>: Number of pixels/voxels in the y-dimension</li><li><code>nz::Int</code>: (3D only) Number of voxels in the z-dimension</li></ul><p><strong>Keywords</strong></p><ul><li><code>oversample::Int=3</code>: Oversampling factor for anti-aliasing. Higher values produce smoother edges but take longer to compute. Default of 3 provides good quality for most applications.</li></ul><p><strong>Returns</strong></p><ul><li><strong>2D</strong>: A <code>ComplexF32</code> matrix of size <code>(nx, ny)</code> representing the phantom image</li><li><strong>3D</strong>: A <code>ComplexF32</code> array of size <code>(nx, ny, nz)</code> representing the phantom volume</li></ul><p><strong>Details</strong></p><p><strong>2D Phantom</strong></p><p>Uses the Toft modification of the classical Shepp-Logan phantom, consisting of 10 ellipses with varying intensities representing different tissue types in a head cross-section.</p><p><strong>3D Phantom</strong></p><p>Generates a 3D extension using ellipsoids with:</p><ul><li>Field-of-view (FOV): 24 cm × 24 cm × 20 cm</li><li>Modified intensities (×10) for inner structures to improve visibility</li><li>Toft&#39;s intensity modifications for the head (1.0) and skull/brain (-0.8) regions</li></ul><p><strong>References</strong></p><ul><li>Shepp, L. A., &amp; Logan, B. F. (1974). &quot;The Fourier reconstruction of a head section.&quot; IEEE Transactions on Nuclear Science, 21(3), 21-43.</li><li>Toft, P. (1996). &quot;The Radon Transform - Theory and Implementation.&quot; PhD thesis, Technical University of Denmark.</li></ul><p><strong>See Also</strong></p><ul><li><a href="#MriReconstructionToolbox.simulate_acquisition"><code>simulate_acquisition</code></a>: Generate k-space data from a phantom</li><li><a href="#MriReconstructionToolbox.coil_sensitivities"><code>coil_sensitivities</code></a>: Generate sensitivity maps for multi-coil simulation</li><li><a href="../acquisition_info/#AcquisitionInfo"><code>AcquisitionInfo</code></a>: Container for acquisition parameters</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/3ea3be3b52ddc35cfbc58dcac146ffed75606167/src/simulation/phantoms.jl#L1-L47">source</a></div></details></article><pre><code class="language-julia hljs">using MIRTjim: jim

# 2D Shepp-Logan
img = shepp_logan(256, 256)  # Returns ComplexF32 array

# 3D Shepp-Logan
img_3d = shepp_logan(128, 128, 64)
jim(img_3d; title=&quot;Shepp-Logan Phantom&quot;, nrow=4, size=(1200,300))</code></pre><p><img src="../3D_shepp_logan_phantom.png" alt="3D_shepp_logan_phantom.png"/></p><h2 id="Coil-Sensitivity-Maps"><a class="docs-heading-anchor" href="#Coil-Sensitivity-Maps">Coil Sensitivity Maps</a><a id="Coil-Sensitivity-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Coil-Sensitivity-Maps" title="Permalink"></a></h2><p>Sensitivity maps model the spatial response of receiver coils in parallel imaging.</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.coil_sensitivities"><a class="docstring-binding" href="#MriReconstructionToolbox.coil_sensitivities"><code>MriReconstructionToolbox.coil_sensitivities</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">coil_sensitivities(nx::Int, ny::Int, nc::Int) -&gt; Array{ComplexF32, 3}
coil_sensitivities(nx::Int, ny::Int, nz::Int, nc::Int) -&gt; Array{ComplexF32, 4}</code></pre><p>Generate simulated sensitivity maps for multi-coil MRI receivers.</p><p><strong>Physics Background</strong></p><p>In parallel MRI, multiple receiver coils are arranged around the imaging subject, each with spatially varying sensitivity profiles. This function simulates realistic coil sensitivity maps based on the physical principles of electromagnetic reception.</p><p><strong>Physical Model</strong></p><p>The sensitivity maps are constructed using:</p><ol><li><p><strong>Spatial Arrangement</strong>: Coils are positioned in a circular array around the field of view, with centers at angles <code>2π(i-1)/nc</code> for coil <code>i</code>, mimicking typical clinical coil arrays.</p></li><li><p><strong>Magnitude Profile</strong>: Each coil&#39;s sensitivity decreases with distance from its center following a Gaussian profile <code>exp(-r²/(2σ²))</code>, where <code>r</code> is the distance from the coil center. This reflects the physical reality that receiver coils are most sensitive to signal sources near them, with sensitivity falling off smoothly with distance.</p></li><li><p><strong>Phase Variation</strong>: A linear phase ramp <code>exp(im(0.5x + 0.3y))</code> is applied to simulate phase variations due to:</p><ul><li>B₀ field inhomogeneities</li><li>Receiver electronics phase offsets</li><li>Geometric positioning effects</li></ul></li><li><p><strong>Normalization</strong>: The maps are normalized using the root-sum-of-squares across all coils, ensuring that <code>√(Σᵢ|sᵢ(x,y)|²) ≈ 1</code> at each spatial location. This preserves signal intensity while maintaining spatial encoding information.</p></li></ol><p><strong>Arguments</strong></p><ul><li><code>nx::Int</code>: Number of pixels in x-direction</li><li><code>ny::Int</code>: Number of pixels in y-direction</li><li><code>nz::Int</code>: Number of pixels in z-direction (for 3D sensitivities)</li><li><code>nc::Int</code>: Number of coils</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{ComplexF32, 3}</code>: Sensitivity maps of size (nx, ny, nc), where each slice along dimension 3 represents one coil&#39;s complex-valued sensitivity profile.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/3ea3be3b52ddc35cfbc58dcac146ffed75606167/src/simulation/sensitivities.jl#L1-L43">source</a></div></details></article><pre><code class="language-julia hljs"># Generate sensitivity maps for 8 coils
smaps = coil_sensitivities(256, 256, 8)

# 3D sensitivity maps
smaps_3d = coil_sensitivities(128, 128, 64, 8)

# Visualize 2D coil sensitivities
jim(smaps; title=&quot;Coil Sensitivity Maps&quot;, nrow=1, size=(1400, 200))</code></pre><p><img src="../coil_sensitivity_maps.png" alt="coil_sensitivity_maps.png"/></p><p><strong>What you get:</strong></p><ul><li>Smooth, realistic sensitivity patterns</li><li>Each coil has higher sensitivity near its location</li><li>Proper phase variations</li><li>Returns ComplexF32 array with shape (nx, ny, [nz,] ncoils)</li></ul><h2 id="Subsampling-Patterns"><a class="docs-heading-anchor" href="#Subsampling-Patterns">Subsampling Patterns</a><a id="Subsampling-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Subsampling-Patterns" title="Permalink"></a></h2><p>Subsampling patterns determine which k-space locations are measured.</p><h3 id="Uniform-Cartesian-Sampling"><a class="docs-heading-anchor" href="#Uniform-Cartesian-Sampling">Uniform Cartesian Sampling</a><a id="Uniform-Cartesian-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Uniform-Cartesian-Sampling" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.UniformRandomSampling"><a class="docstring-binding" href="#MriReconstructionToolbox.UniformRandomSampling"><code>MriReconstructionToolbox.UniformRandomSampling</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">UniformRandomSampling(acceleration::Float64; center_fraction::Float64=0.1)</code></pre><p>Create a uniform random sampling pattern with the specified acceleration factor and center fraction. The <code>acceleration</code> parameter controls the overall undersampling factor, while the <code>center_fraction</code> parameter specifies the fraction of low-frequency k-space positions to be fully sampled.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/3ea3be3b52ddc35cfbc58dcac146ffed75606167/src/simulation/subsampling.jl#L3-L9">source</a></div></details></article><h4 id="Example:-2D-Uniform-Random-Sampling"><a class="docs-heading-anchor" href="#Example:-2D-Uniform-Random-Sampling">Example: 2D Uniform Random Sampling</a><a id="Example:-2D-Uniform-Random-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-2D-Uniform-Random-Sampling" title="Permalink"></a></h4><pre><code class="language-julia hljs">using Plots

# Center fraction = 0.1 (10% fully sampled center, default)
pdf = UniformRandomSampling(3.0)
pattern = create_sampling_pattern(pdf, (256, 256))
p1 = jim(to_displayable_mask(pattern, (256, 256)); title = &quot;cf=0.1&quot;)

# Center fraction = 0.3 (30% fully sampled center)
pdf = UniformRandomSampling(3.0, 0.3)
pattern = create_sampling_pattern(pdf, (256, 256))
p2 = jim(to_displayable_mask(pattern, (256, 256)); title = &quot;cf=0.3&quot;)

# 2D subsampling: freq encoding also subsampled (not realistic, for demo)
pdf = UniformRandomSampling(3.0)
pattern = create_sampling_pattern(pdf, (256, 256), subsample_freq_encoding=true)
p3 = jim(to_displayable_mask(pattern, (256, 256)); title = &quot;Freq encoding subsampled&quot;)

jim(p1, p2, p3; layout = (1, 3), size = (1000, 300))</code></pre><p><img src="../2D_uniform_random_sampling_weights.png" alt="2D_uniform_random_sampling_weights.png"/></p><h4 id="Example:-3D-Uniform-Random-Sampling"><a class="docs-heading-anchor" href="#Example:-3D-Uniform-Random-Sampling">Example: 3D Uniform Random Sampling</a><a id="Example:-3D-Uniform-Random-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-3D-Uniform-Random-Sampling" title="Permalink"></a></h4><pre><code class="language-julia hljs">pdf = UniformRandomSampling(4.0, 0.1)
pattern_3d = create_sampling_pattern(pdf, (128, 128, 64))
mask = zeros(Bool, 128, 128, 64)
mask[pattern_3d...] .= true
p1 = jim(mask[:, :, 32]; title=&quot;x-y plane&quot;)
p2 = jim(mask[:, 64, :]; title=&quot;x-z plane&quot;)
p3 = jim(mask[64, :, :]; title=&quot;y-z plane&quot;)
jim(p1, p2, p3; layout=(1,3), size=(1000,300))</code></pre><p><img src="../3D_uniform_random_sampling_weights.png" alt="3D_uniform_random_sampling_weights.png"/></p><h3 id="Variable-Density-Sampling"><a class="docs-heading-anchor" href="#Variable-Density-Sampling">Variable Density Sampling</a><a id="Variable-Density-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Density-Sampling" title="Permalink"></a></h3><p>The most common pattern for compressed sensing. There are many options for generating variable density patterns.</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.GaussianDistribution"><a class="docstring-binding" href="#MriReconstructionToolbox.GaussianDistribution"><code>MriReconstructionToolbox.GaussianDistribution</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">GaussianDistribution(std::Float64=1/3)</code></pre><p>Create a Gaussian variable density distribution with the specified standard deviation <code>std</code>. The sampling probability follows a Gaussian profile centered at k-space center:     W(r) = exp(-0.5 * (r / std)^2), where r is the normalized distance from the k-space center.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/3ea3be3b52ddc35cfbc58dcac146ffed75606167/src/simulation/subsampling.jl#L21-L27">source</a></div></details></article><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.PolynomialDistribution"><a class="docstring-binding" href="#MriReconstructionToolbox.PolynomialDistribution"><code>MriReconstructionToolbox.PolynomialDistribution</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PolynomialDistribution(p::Float64=4)</code></pre><p>Create a Polynomial variable density distribution with the specified exponent <code>p</code>. The sampling probability is proportional to power of the distance from the k-space center:     W(r) = (1 - r)^p, where r is the normalized distance from the k-space center.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/3ea3be3b52ddc35cfbc58dcac146ffed75606167/src/simulation/subsampling.jl#L36-L42">source</a></div></details></article><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.VariableDensitySampling"><a class="docstring-binding" href="#MriReconstructionToolbox.VariableDensitySampling"><code>MriReconstructionToolbox.VariableDensitySampling</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">VariableDensitySampling(distribution::VariableDensityDistribution, acceleration::Float64; center_fraction::Float64=0.1)</code></pre><p>Create a variable density random sampling pattern based on the specified distribution, acceleration factor, and center fraction. The <code>distribution</code> parameter can be either <code>GaussianDistribution</code> or <code>PolynomialDistribution</code>. The <code>acceleration</code> parameter controls the overall undersampling factor, while the <code>center_fraction</code> parameter specifies the fraction of low-frequency k-space positions to be fully sampled.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/3ea3be3b52ddc35cfbc58dcac146ffed75606167/src/simulation/subsampling.jl#L51-L58">source</a></div></details></article><h4 id="Example:-Different-Variable-Density-Patterns-in-2D"><a class="docs-heading-anchor" href="#Example:-Different-Variable-Density-Patterns-in-2D">Example: Different Variable Density Patterns in 2D</a><a id="Example:-Different-Variable-Density-Patterns-in-2D-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Different-Variable-Density-Patterns-in-2D" title="Permalink"></a></h4><pre><code class="language-julia hljs">gaussian_pdf₁ = VariableDensitySampling(GaussianDistribution(1/3), 3.0)
gaussian_pattern₁ = create_sampling_pattern(gaussian_pdf₁, (256, 256))
W = MriReconstructionToolbox.construct_weights(gaussian_pdf₁, (256,))

p1 = plot(W; legend = false)
p2 = jim(to_displayable_mask(gaussian_pattern₁, (256, 256)))
jim(p1, p2; layout=(1,2), plot_title=&quot;Gaussian std=1/3&quot;, size = (700, 300))</code></pre><p><img src="../gaussian_sampling_pattern_1.png" alt="gaussian_sampling_pattern_1.png"/></p><pre><code class="language-julia hljs">gaussian_pdf₂ = VariableDensitySampling(GaussianDistribution(1/5), 3.0)
gaussian_pattern₂ = create_sampling_pattern(gaussian_pdf₂, (256, 256))
W = MriReconstructionToolbox.construct_weights(gaussian_pdf₂, (256,))

p1 = plot(W; legend = false)
p2 = jim(to_displayable_mask(gaussian_pattern₂, (256, 256)))
jim(p1, p2; layout=(1,2), plot_title=&quot;Gaussian std=1/5&quot;, size = (700, 300))</code></pre><p><img src="../gaussian_sampling_pattern_2.png" alt="gaussian_sampling_pattern_2.png"/></p><pre><code class="language-julia hljs">poly_pdf₁ = VariableDensitySampling(PolynomialDistribution(2), 3.0)
poly_pattern₁ = create_sampling_pattern(poly_pdf₁, (256, 256))

W = MriReconstructionToolbox.construct_weights(poly_pdf₁, (256,))
p1 = plot(W; legend = false)
p2 = jim(to_displayable_mask(poly_pattern₁, (256, 256)))
jim(p1, p2; layout=(1,2), plot_title=&quot;Polynomial p=2&quot;, size = (700, 300))</code></pre><p><img src="../polynomial_sampling_pattern_1.png" alt="polynomial_sampling_pattern_1.png"/></p><pre><code class="language-julia hljs">poly_pdf₂ = VariableDensitySampling(PolynomialDistribution(4), 3.0)
poly_pattern₂ = create_sampling_pattern(poly_pdf₂, (256, 256))
W = MriReconstructionToolbox.construct_weights(poly_pdf₂, (256,))
p1 = plot(W; legend = false)
p2 = jim(to_displayable_mask(poly_pattern₂, (256, 256)))
jim(p1, p2; layout=(1,2), plot_title=&quot;Polynomial p=4&quot;, size = (700, 300))</code></pre><p><img src="../polynomial_sampling_pattern_2.png" alt="polynomial_sampling_pattern_2.png"/></p><h4 id="Example:-Variable-Density-in-3D"><a class="docs-heading-anchor" href="#Example:-Variable-Density-in-3D">Example: Variable Density in 3D</a><a id="Example:-Variable-Density-in-3D-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Variable-Density-in-3D" title="Permalink"></a></h4><pre><code class="language-julia hljs">poly_pdf = VariableDensitySampling(PolynomialDistribution(2), 3.0)
poly_pattern = create_sampling_pattern(poly_pdf, (256, 256, 256))
mask = zeros(Bool, 256, 256, 256)
mask[poly_pattern...] .= true
p1 = jim(mask[:, :, 128]; title=&quot;x-y plane&quot;)
p2 = jim(mask[:, 128, :]; title=&quot;x-z plane&quot;)
p3 = jim(mask[128, :, :]; title=&quot;y-z plane&quot;)
jim(p1, p2, p3; layout=(1,3), size=(900,200))</code></pre><p><img src="../3D_variable_density_sampling_weights.png" alt="3D_variable_density_sampling_weights.png"/></p><h3 id="Poisson-Disk-Sampling"><a class="docs-heading-anchor" href="#Poisson-Disk-Sampling">Poisson Disk Sampling</a><a id="Poisson-Disk-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Poisson-Disk-Sampling" title="Permalink"></a></h3><p>Spatially uniform but avoiding clustering.</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.PoissonDiskSampling"><a class="docstring-binding" href="#MriReconstructionToolbox.PoissonDiskSampling"><code>MriReconstructionToolbox.PoissonDiskSampling</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">PoissonDiskSampling(acceleration::Float64, center_fraction::Float64=0.1)</code></pre><p>Create a Poisson disk sampling pattern with the specified acceleration factor and center fraction. The <code>acceleration</code> parameter controls the overall undersampling factor, while the <code>center_fraction</code> parameter specifies the fraction of low-frequency k-space positions to be fully sampled.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/3ea3be3b52ddc35cfbc58dcac146ffed75606167/src/simulation/subsampling.jl#L70-L76">source</a></div></details></article><pre><code class="language-julia hljs">pdf = PoissonDiskSampling(3.0)
pattern = create_sampling_pattern(pdf, (256, 256), subsample_freq_encoding=true)
jim(to_displayable_mask(pattern, (256, 256)); title=&quot;Poisson Disk Sampling&quot;, size = (300, 300))</code></pre><p><img src="../poisson_disk_sampling_pattern.png" alt="poisson_disk_sampling_pattern.png"/></p><p><strong>Properties:</strong></p><ul><li>Maintains minimum distance between samples</li><li>More uniform coverage than random</li><li>Good incoherence properties</li></ul><h2 id="Simulate-Acquisition"><a class="docs-heading-anchor" href="#Simulate-Acquisition">Simulate Acquisition</a><a id="Simulate-Acquisition-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-Acquisition" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.simulate_acquisition"><a class="docstring-binding" href="#MriReconstructionToolbox.simulate_acquisition"><code>MriReconstructionToolbox.simulate_acquisition</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">simulate_acquisition(image, acq_info::AcquisitionInfo)</code></pre><p>Simulate MRI k-space acquisition from a given image using the specified acquisition parameters.</p><p><strong>Arguments</strong></p><ul><li><code>image</code>: The input image to be transformed into k-space data. Can be a standard array or a <code>NamedDimsArray</code>.</li><li><code>acq_info::AcquisitionInfo</code>: An <code>AcquisitionInfo</code> object containing acquisition parameters such as sensitivity maps, subsampling pattern, and whether the acquisition is 3D.</li></ul><p><strong>Returns</strong></p><ul><li>An updated <code>AcquisitionInfo</code> object with the simulated k-space data stored in the <code>kspace_data</code> field.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/3ea3be3b52ddc35cfbc58dcac146ffed75606167/src/simulation/simulate_acquisition.jl#L1-L12">source</a></div></details></article><h2 id="Advanced-Simulation"><a class="docs-heading-anchor" href="#Advanced-Simulation">Advanced Simulation</a><a id="Advanced-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Simulation" title="Permalink"></a></h2><h3 id="Adding-Noise"><a class="docs-heading-anchor" href="#Adding-Noise">Adding Noise</a><a id="Adding-Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Noise" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Simulate acquisition
acq = simulate_acquisition(img_true, acq)

# Add Gaussian noise to k-space
noise_level = 0.01  # Adjust based on desired SNR
noise = noise_level * randn(ComplexF32, size(acq.kspace_data))
acq = AcquisitionInfo(acq; kspace_data=acq.kspace_data .+ noise)

# Reconstruct noisy data
img_recon = reconstruct(acq, L1Wavelet2D(5e-3))</code></pre><h3 id="Custom-Subsampling-Patterns"><a class="docs-heading-anchor" href="#Custom-Subsampling-Patterns">Custom Subsampling Patterns</a><a id="Custom-Subsampling-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Subsampling-Patterns" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Manual pattern creation
mask = falses(256, 256)

# Fully sample center
mask[118:138, 118:138] .= true

# Random sampling elsewhere
for i in 1:256, j in 1:256
    if !mask[i,j] &amp;&amp; rand() &lt; 0.2  # 20% sampling
        mask[i,j] = true
    end
end

# Use custom mask
acq = AcquisitionInfo(img, false; subsampling=mask)</code></pre><h3 id="Cartesian-Line-Sampling"><a class="docs-heading-anchor" href="#Cartesian-Line-Sampling">Cartesian Line Sampling</a><a id="Cartesian-Line-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-Line-Sampling" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Sample every 4th phase encoding line
ny = 256
lines_to_sample = [1:4:ny; div(ny,2)-10:div(ny,2)+10]  # Skip plus center

mask = falses(256, 256)
mask[:, lines_to_sample] .= true

acq = AcquisitionInfo(img, false; subsampling=mask)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acquisition_info/">« AcquisitionInfo</a><a class="docs-footer-nextpage" href="../reconstruction/">Reconstruction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Tuesday 18 November 2025 20:18">Tuesday 18 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
