<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization Algorithms · MriReconstructionToolbox.jl</title><meta name="title" content="Optimization Algorithms · MriReconstructionToolbox.jl"/><meta property="og:title" content="Optimization Algorithms · MriReconstructionToolbox.jl"/><meta property="twitter:title" content="Optimization Algorithms · MriReconstructionToolbox.jl"/><meta name="description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="og:description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="twitter:description" content="Documentation for MriReconstructionToolbox.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MriReconstructionToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../theory/">Theoretical Background</a></li><li><span class="tocitem">High-level Interface</span><ul><li><a class="tocitem" href="../acquisition_info/">AcquisitionInfo</a></li><li><a class="tocitem" href="../simulation/">Simulation Tools</a></li><li><a class="tocitem" href="../reconstruction/">Reconstruction</a></li><li><a class="tocitem" href="../regularization/">Regularization</a></li><li class="is-active"><a class="tocitem" href>Optimization Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Quick-Algorithm-Selection"><span>Quick Algorithm Selection</span></a></li><li><a class="tocitem" href="#ProximalAlgorithms.jl-Interface"><span>ProximalAlgorithms.jl Interface</span></a></li><li><a class="tocitem" href="#Default-Algorithms"><span>Default Algorithms</span></a></li><li><a class="tocitem" href="#Tuning-Algorithm-Parameters"><span>Tuning Algorithm Parameters</span></a></li><li><a class="tocitem" href="#Advanced-Usage"><span>Advanced Usage</span></a></li></ul></li><li><a class="tocitem" href="../nameddims/">Named Dimensions</a></li><li><a class="tocitem" href="../decomposition/">Problem Decomposition</a></li></ul></li><li><span class="tocitem">Low-Level Interface</span><ul><li><a class="tocitem" href="../../low-level/operators/">MRI Operators</a></li><li><a class="tocitem" href="../../low-level/custom_reconstruction/">Custom Reconstruction</a></li><li><a class="tocitem" href="../../low-level/abstract_operators/">AbstractOperators.jl</a></li><li><a class="tocitem" href="../../low-level/proximal_operators/">ProximalOperators.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">High-level Interface</a></li><li class="is-active"><a href>Optimization Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/master/docs/src/high-level/algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimization-Algorithms"><a class="docs-heading-anchor" href="#Optimization-Algorithms">Optimization Algorithms</a><a id="Optimization-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Algorithms" title="Permalink"></a></h1><p>MriReconstructionToolbox supports multiple iterative optimization algorithms for solving MRI reconstruction problems. This guide helps you choose and configure the right algorithm for your needs.</p><h2 id="Quick-Algorithm-Selection"><a class="docs-heading-anchor" href="#Quick-Algorithm-Selection">Quick Algorithm Selection</a><a id="Quick-Algorithm-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Algorithm-Selection" title="Permalink"></a></h2><p><strong>Not sure which to use?</strong> Let <code>reconstruct()</code> choose automatically:</p><pre><code class="language-julia hljs">img = reconstruct(acq, regularization)
# Automatically selects appropriate algorithm</code></pre><p><strong>How does it decides?</strong> Here&#39;s a decision tree:</p><pre><code class="nohighlight hljs">Is your problem smooth (no L1, TV, etc.)?
├─ Yes → Use CGNR (Conjugate Gradient Normal Residual)
└─ No → Does it have a single non-smooth regularizer where the wrapped operator is symmetric* (e.g. wavelets, temporal Fourier)?
    ├─ Yes → Use FISTA (Fast Iterative Shrinkage-Thresholding Algorithm)
    └─ No → Use ADMM (Alternating Direction Method of Multipliers)</code></pre><p>*Symmetric means the operator satisfies <code>E&#39; * E = E * E&#39;</code>, e.g. Fourier-based operators. But actually a more loose condition (<code>is_AAc_diagonal</code> from <code>OperatorCore.jl</code>) is used: <code>E&#39; * E = diag(d)</code> for some <code>d</code>, i.e. the normal operator is equal to element-wise scaling.</p><h2 id="ProximalAlgorithms.jl-Interface"><a class="docs-heading-anchor" href="#ProximalAlgorithms.jl-Interface">ProximalAlgorithms.jl Interface</a><a id="ProximalAlgorithms.jl-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#ProximalAlgorithms.jl-Interface" title="Permalink"></a></h2><p>MriReconstructionToolbox builds on <a href="https://github.com/JuliaFirstOrder/ProximalAlgorithms.jl">ProximalAlgorithms.jl</a>. All algorithms from that package can be used directly. There are three recommended algorithms for MRI reconstruction used by default in <code>reconstruct()</code>:</p><ul><li><code>CGNR</code>: Conjugate Gradient Normal Residual for smooth problems</li><li><code>FISTA</code>: Fast Iterative Shrinkage-Thresholding Algorithm for single non-smooth regularizer</li><li><code>ADMM</code>: Alternating Direction Method of Multipliers for multiple regularizers</li></ul><p>All algorithms from this library share a common interface with the following parameters:</p><ul><li><code>maxit::Int</code>: maximum number of iteration</li><li><code>stop::Function</code>: termination condition, <code>stop(::T, state)</code> should return <code>true</code> when to stop the iteration</li><li><code>solution::Function</code>: solution mapping, <code>solution(::T, state)</code> should return the identified solution</li><li><code>verbose::Bool</code>: whether the algorithm state should be displayed</li><li><code>freq::Int</code>: every how many iterations to display the algorithm state</li><li><code>summary::Function</code>: function returning a summary of the iteration state, <code>summary(k::Int, iter::T, state)</code> should return a vector of pairs <code>(name, value)</code></li><li><code>display::Function</code>: display function, <code>display(k::Int, alg, iter::T, state)</code> should display a summary of the iteration state</li></ul><h2 id="Default-Algorithms"><a class="docs-heading-anchor" href="#Default-Algorithms">Default Algorithms</a><a id="Default-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Default-Algorithms" title="Permalink"></a></h2><h3 id="Conjugate-Gradient-Normal-Residual-(CGNR)"><a class="docs-heading-anchor" href="#Conjugate-Gradient-Normal-Residual-(CGNR)">Conjugate Gradient Normal Residual (CGNR)</a><a id="Conjugate-Gradient-Normal-Residual-(CGNR)-1"></a><a class="docs-heading-anchor-permalink" href="#Conjugate-Gradient-Normal-Residual-(CGNR)" title="Permalink"></a></h3><p>This algorithm solves linear systems of the form</p><pre><code class="nohighlight hljs">argminₓ ‖Ax - b‖₂² + ‖λx‖₂²</code></pre><p>where <code>A</code> is a symmetric positive definite linear operator, and <code>b</code> is the measurement vector, and <code>λ</code> is the L2 regularization parameter. <code>λ</code> might be scalar or an array of the same size as <code>x</code>. If <code>λ</code> is zero, the problem reduces to a least-squares problem:</p><pre><code class="nohighlight hljs">argminₓ ‖Ax - b‖₂²</code></pre><p><strong>Best for:</strong> Least-squares problems with optional Tikhonov regularization</p><p><strong>Properties:</strong></p><ul><li>Solves normal equations: A&#39;A·x = A&#39;·b</li><li>Good for ill-conditioned problems</li><li>Variant of CG with different mathematical properties</li></ul><p><strong>Parameters:</strong></p><ul><li><code>λ=0</code>: L2 regularization parameter (default: 0)</li><li><code>P</code>: preconditioner (optional)</li><li><code>P_is_inverse</code>: whether <code>P</code> is the inverse of the preconditioner (default: <code>false</code>)</li></ul><p><strong>References:</strong></p><ol><li>Hestenes, M.R. and Stiefel, E., &quot;Methods of conjugate gradients for solving linear systems.&quot; Journal of Research of the National Bureau of Standards 49.6 (1952): 409-436.</li></ol><p><strong>Pros:</strong></p><ul><li>✅ Very fast convergence for appropriate problems</li><li>✅ No hyperparameter tuning</li><li>✅ Memory efficient</li></ul><p><strong>Cons:</strong></p><ul><li>❌ Only for a small class of problems</li><li>❌ Can&#39;t handle L1, TV, or other non-smooth terms</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">img = reconstruct(data, Tikhonov(1e-4), CGNR(maxit=20));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constructing encoding operator: 1.02 ms (8.4 M allocations: 8.011 MiB)
Getting initial estimate: 1.99 ms (131.21 k allocations: 128.133 KiB)
Computing scaling factor: 683.91 µs (131.49 k allocations: 128.406 KiB)
Scaling k-space data: 132.14 µs (263.46 k allocations: 257.289 KiB)
Normalizing encoding operator: 24.99 ms (1.37 M allocations: 1.308 MiB)
Building optimization model: 1.45 ms (1.32 M allocations: 1.260 MiB)
Starting reconstructing image...
      | ‖Aᴴb - (AᴴA + λI)x‖ |   λ‖x‖²
------|---------------------|-----------
    5 |           2.711e-01 | 1.299e-05
   10 |           1.094e-01 | 1.384e-05
   15 |           3.166e-02 | 1.402e-05
   20 |           1.997e-02 | 1.420e-05
   25 |           1.308e-02 | 1.429e-05
   30 |           1.809e-02 | 1.446e-05
   35 |           7.835e-03 | 1.455e-05
   40 |           8.503e-03 | 1.462e-05
   45 |           3.332e-03 | 1.467e-05
   50 |           5.168e-03 | 1.470e-05
   55 |           3.981e-03 | 1.473e-05
   60 |           2.421e-03 | 1.475e-05
   65 |           1.853e-03 | 1.477e-05
   70 |           1.607e-03 | 1.478e-05
   75 |           3.048e-03 | 1.479e-05
   80 |           1.576e-03 | 1.481e-05
   85 |           1.563e-03 | 1.483e-05
   90 |           1.128e-03 | 1.484e-05
   95 |           1.945e-03 | 1.485e-05
  100 |           1.381e-03 | 1.487e-05
Finished reconstructing image in 1.14 s (98.18 M allocations: 93.632 MiB, 87.68% compilation time)
Inverse scaling image: 17.83 µs (48 allocations: 48 bytes)
Total time: 1.89 s</code></pre><h3 id="Fast-Iterative-Shrinkage-Thresholding-Algorithm-(FISTA)"><a class="docs-heading-anchor" href="#Fast-Iterative-Shrinkage-Thresholding-Algorithm-(FISTA)">Fast Iterative Shrinkage-Thresholding Algorithm (FISTA)</a><a id="Fast-Iterative-Shrinkage-Thresholding-Algorithm-(FISTA)-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-Iterative-Shrinkage-Thresholding-Algorithm-(FISTA)" title="Permalink"></a></h3><p>This algorithm solves convex optimization problems of the form</p><pre><code class="nohighlight hljs">minimize f(x) + g(x),</code></pre><p>where <code>f</code> is smooth.</p><p><strong>Best for:</strong> Single non-smooth regularizer (e.g. L1) with symmetric operator (e.g. wavelets)</p><div class="admonition is-info" id="Note-4545e699735593e7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4545e699735593e7" title="Permalink"></a></header><div class="admonition-body"><p>FISTA is only an alias for FastForwardBackward from ProximalAlgorithms.jl.</p></div></div><p><strong>Properties:</strong></p><ul><li>Accelerated gradient method</li><li>Handles non-smooth regularization</li><li>Faster convergence than basic ISTA</li></ul><p><strong>Parameters:</strong></p><ul><li><code>mf=0</code>: convexity modulus <code>f</code> (the smooth part of the objective, usually data fidelity term)</li><li><code>Lf=nothing</code>: Lipschitz constant of the gradient of <code>f</code> (usually equals to 1 because the Lipschitz contant of squared L2 norm is 1 and <code>get_encoding_operator</code> returns a normalized operator)</li><li><code>gamma=nothing</code>: stepsize, defaults to <code>1/Lf</code> if <code>Lf</code> is set, and <code>nothing</code> otherwise.</li><li><code>adaptive=true</code>: makes <code>gamma</code> adaptively adjust during the iterations; this is by default <code>gamma === nothing</code>.</li><li><code>minimum_gamma=1e-7</code>: lower bound to <code>gamma</code> in case <code>adaptive == true</code>.</li><li><code>reduce_gamma=0.5</code>: factor by which to reduce <code>gamma</code> in case <code>adaptive == true</code>, during backtracking.</li><li><code>increase_gamma=1.0</code>: factor by which to increase <code>gamma</code> in case <code>adaptive == true</code>, before backtracking.</li><li><code>extrapolation_sequence=nothing</code>: sequence (iterator) of extrapolation coefficients to use for acceleration.</li></ul><p><strong>References:</strong></p><ol><li>Tseng, &quot;On Accelerated Proximal Gradient Methods for Convex-Concave Optimization&quot; (2008).</li><li>Beck, Teboulle, &quot;A Fast Iterative Shrinkage-Thresholding Algorithm for Linear Inverse Problems&quot;, SIAM Journal on Imaging Sciences, vol. 2, no. 1, pp. 183-202 (2009).</li></ol><p><strong>Pros:</strong></p><ul><li>✅ Fast for single regularizer</li><li>✅ Proven convergence guarantees</li><li>✅ Accelerated compared to basic gradient descent</li></ul><p><strong>Cons:</strong></p><ul><li>❌ Only one regularizer</li><li>❌ Requires Lipschitz constant (usually auto-estimated)</li><li>❌ Can be sensitive to step size</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">img = reconstruct(data, L1Wavelet2D(5e-3), FISTA(maxit=100));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constructing encoding operator: 979.37 µs (8.4 M allocations: 8.011 MiB)
Getting initial estimate: 2.11 ms (131.21 k allocations: 128.133 KiB)
Computing scaling factor: 710.87 µs (131.49 k allocations: 128.406 KiB)
Scaling k-space data: 168.37 µs (263.46 k allocations: 257.289 KiB)
Normalizing encoding operator: 24.99 ms (1.37 M allocations: 1.308 MiB)
Building optimization model: 1.03 ms (1.32 M allocations: 1.262 MiB)
Starting reconstructing image...
      |   f(x)    |   g(z)    | ‖x - z‖/γ
------|-----------|-----------|-----------
    5 | 1.806e-01 | 4.469e+00 | 1.743e-02
   10 | 1.341e-01 | 4.256e+00 | 6.171e-03
   15 | 1.307e-01 | 4.125e+00 | 4.932e-03
   20 | 1.276e-01 | 4.069e+00 | 5.017e-03
   25 | 1.267e-01 | 4.044e+00 | 3.661e-03
   30 | 1.265e-01 | 4.034e+00 | 3.653e-03
   35 | 1.265e-01 | 4.031e+00 | 2.047e-03
   40 | 1.262e-01 | 4.031e+00 | 1.121e-03
   45 | 1.262e-01 | 4.030e+00 | 1.064e-03
   50 | 1.262e-01 | 4.029e+00 | 7.612e-04
   55 | 1.263e-01 | 4.028e+00 | 4.988e-04
   60 | 1.262e-01 | 4.027e+00 | 5.077e-04
   65 | 1.262e-01 | 4.027e+00 | 3.043e-04
   70 | 1.262e-01 | 4.027e+00 | 2.235e-04
   75 | 1.262e-01 | 4.027e+00 | 2.213e-04
   80 | 1.262e-01 | 4.027e+00 | 1.948e-04
   85 | 1.263e-01 | 4.027e+00 | 1.055e-04
Finished reconstructing image in 762.02 ms (72.25 M allocations: 68.906 MiB, 65.5% compilation time)
Inverse scaling image: 20.5 µs (48 allocations: 48 bytes)
Total time: 912.93 ms</code></pre><h3 id="Alternating-Direction-Method-of-Multipliers-(ADMM)"><a class="docs-heading-anchor" href="#Alternating-Direction-Method-of-Multipliers-(ADMM)">Alternating Direction Method of Multipliers (ADMM)</a><a id="Alternating-Direction-Method-of-Multipliers-(ADMM)-1"></a><a class="docs-heading-anchor-permalink" href="#Alternating-Direction-Method-of-Multipliers-(ADMM)" title="Permalink"></a></h3><p>This algorithm solves optimization problems of the form</p><pre><code class="nohighlight hljs">minimize ½‖Ax - b‖²₂ + ∑ᵢ gᵢ(Bᵢx)</code></pre><p>where:</p><ul><li><code>A</code> is a linear operator</li><li><code>b</code> is the measurement vector</li><li><code>gᵢ</code> are proximable functions with associated linear operators <code>Bᵢ</code></li></ul><p><strong>Best for:</strong> Multiple regularizers or complex constraints</p><p><strong>Properties:</strong></p><ul><li>Splits problem into simpler subproblems</li><li>Handles multiple regularizers naturally</li><li>Handles contraints with non-symmetric operators (e.g. total variation)</li></ul><p><strong>Parameters:</strong></p><ul><li><code>P=nothing</code>: preconditioner for CG (optional)</li><li><code>P_is_inverse=false</code>: whether <code>P</code> is the inverse of the preconditioner</li><li><code>eps_abs=0</code>: absolute tolerance for convergence</li><li><code>eps_rel=1</code>: relative tolerance for convergence</li><li><code>cg_tol=1e-6</code>: CG tolerance</li><li><code>cg_maxit=100</code>: maximum CG iterations</li><li><code>y0=nothing</code>: initial dual variables</li><li><code>z0=nothing</code>: initial auxiliary variables</li><li><code>penalty_sequence=nothing</code>: penalty sequence for adaptive rho updating. The following options are available:<ul><li><code>FixedPenalty(rho)</code>: fixed penalty sequence with specified rho values</li><li><code>ResidualBalancingPenalty(rho; mu=10.0, tau=2.0)</code>: adaptive penalty sequence based on residual balancing [2]</li><li><code>SpectralRadiusBoundPenalty(rho; tau=10.0, eta=100.0)</code>: adaptive penalty sequence based on spectral radius bounds [3]</li><li><code>SpectralRadiusApproximationPenalty(rho; tau=10.0)</code>: adaptive penalty sequence based on spectral radius approximation [4]</li></ul>Note: rho can be specified either as the <code>rho</code> parameter or within the penalty sequence constructor, but not both.</li></ul><p>The adaptive penalty parameter schemes are implemented through the penalty sequence types,  following various strategies from the literature. See the individual penalty sequence types  for their specific update rules and references.</p><p><strong>References:</strong></p><ol><li>Boyd, S., Parikh, N., Chu, E., Peleato, B., &amp; Eckstein, J. (2011). Distributed optimization and statistical learning via the alternating direction method of multipliers. Foundations and Trends in Machine Learning, 3(1), 1-122.</li><li>He, B. S., Yang, H., &amp; Wang, S. L. (2000). Alternating direction method with self-adaptive penalty parameters for monotone variational inequalities. Journal of Optimization Theory and applications, 106(2), 337-356.</li><li>Lorenz, D. A., &amp; Tran-Dinh, Q. (2019). Non-stationary Douglas–Rachford and alternating direction method of multipliers: Adaptive step-sizes and convergence. Computational Optimization and Applications, 74(1), 67–92. https://doi.org/10.1007/s10589-019-00106-9</li><li>Mccann, M. T., &amp; Wohlberg, B. (2024). Robust and Simple ADMM Penalty Parameter Selection. IEEE Open Journal of Signal Processing, 5, 402–420. https://doi.org/10.1109/OJSP.2023.3349115</li></ol><p><strong>Pros:</strong></p><ul><li>✅ Handles multiple regularizers</li><li>✅ Very robust and stable</li><li>✅ Good for complex problems</li></ul><p><strong>Cons:</strong></p><ul><li>❌ Slower than FISTA for single regularizer</li><li>❌ More parameters to tune</li><li>❌ Each iteration more expensive</li><li>❌ No convergence guarantees in general</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Multiple regularizers
reg = (L1Wavelet2D(5e-3), TotalVariation2D(1e-3))
img = reconstruct(data, reg, ADMM(maxit=50));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constructing encoding operator: 978.9 µs (8.4 M allocations: 8.011 MiB)
Getting initial estimate: 1.08 ms (131.21 k allocations: 128.133 KiB)
Computing scaling factor: 675.29 µs (131.49 k allocations: 128.406 KiB)
Scaling k-space data: 71.34 µs (263.46 k allocations: 257.289 KiB)
Normalizing encoding operator: 24.74 ms (1.37 M allocations: 1.308 MiB)
Building optimization model: 1.45 ms (1.33 M allocations: 1.264 MiB)
Starting reconstructing image...
      |  Δx_norm  | norm(rᵏ_1) | norm(sᵏ_1) | norm(rᵏ_2) | norm(sᵏ_2) |    ρ_1    |    ρ_2    | CG iters
------|-----------|------------|------------|------------|------------|-----------|-----------|----------
    5 | 3.971e+00 |  4.621e+00 |  2.441e-02 |  5.611e+00 |  2.633e-02 | 9.778e-03 | 3.902e-03 |       10
   10 | 4.727e-01 |  5.582e-01 |  1.878e-02 |  1.089e+00 |  1.073e-02 | 4.278e-02 | 8.235e-03 |       10
   15 | 8.406e-02 |  6.960e-02 |  3.245e-02 |  2.168e-01 |  2.111e-02 | 5.796e-01 | 6.055e-02 |       10
   20 | 4.819e-02 |  2.715e-02 |  9.577e-03 |  4.200e-02 |  1.124e-02 | 2.043e-01 | 1.081e-01 |       10
   25 | 6.235e-02 |  8.391e-02 |  1.221e-03 |  8.074e-02 |  4.086e-03 | 2.001e-02 | 2.523e-02 |       10
   30 | 1.397e-02 |  7.747e-03 |  7.705e-03 |  4.056e-02 |  5.191e-03 | 1.049e+00 | 8.437e-02 |        8
   35 | 1.459e-02 |  6.509e-03 |  3.828e-03 |  7.682e-03 |  4.144e-03 | 2.680e-01 | 1.766e-01 |       10
   40 | 2.634e-02 |  5.772e-02 |  2.524e-04 |  4.532e-02 |  1.650e-03 | 9.527e-03 | 2.591e-02 |       10
   45 | 9.395e-03 |  3.872e-03 |  4.850e-03 |  1.974e-02 |  2.197e-03 | 7.621e-01 | 6.481e-02 |        9
   50 | 6.267e-02 |  4.515e-02 |  6.263e-04 |  4.259e-02 |  1.735e-03 | 1.106e-02 | 2.411e-02 |       10
   55 | 1.554e-02 |  1.070e-02 |  3.209e-03 |  1.578e-02 |  3.132e-03 | 3.831e-01 | 7.083e-02 |       10
   60 | 6.333e-02 |  3.920e-02 |  8.805e-04 |  4.163e-02 |  1.161e-03 | 1.522e-02 | 1.816e-02 |       10
   65 | 1.533e-02 |  1.227e-02 |  2.640e-03 |  1.162e-02 |  2.867e-03 | 2.661e-01 | 7.872e-02 |       10
   70 | 5.633e-02 |  4.338e-02 |  7.736e-04 |  4.820e-02 |  7.250e-04 | 1.488e-02 | 1.276e-02 |       10
   75 | 1.457e-02 |  8.993e-03 |  2.421e-03 |  9.763e-03 |  2.440e-03 | 2.391e-01 | 6.522e-02 |       10
   80 | 3.623e-02 |  4.621e-02 |  4.759e-04 |  5.142e-02 |  4.144e-04 | 1.373e-02 | 1.081e-02 |       10
   85 | 1.653e-02 |  4.847e-03 |  2.595e-03 |  9.881e-03 |  1.724e-03 | 1.881e-01 | 3.800e-02 |       10
   90 | 1.687e-02 |  4.513e-02 |  3.176e-04 |  4.339e-02 |  4.772e-04 | 2.396e-02 | 2.138e-02 |       10
   95 | 4.634e-02 |  1.990e-02 |  2.258e-03 |  2.541e-02 |  1.225e-03 | 5.320e-02 | 1.251e-02 |       10
  100 | 2.510e-02 |  3.558e-02 |  1.689e-03 |  2.801e-02 |  2.137e-03 | 8.200e-02 | 5.685e-02 |       10
Finished reconstructing image in 3.85 s (735.25 M allocations: 701.192 MiB, 1.51% gc time, 10.97% compilation time)
Inverse scaling image: 14.17 µs (48 allocations: 48 bytes)
Total time: 4.0 s</code></pre><h2 id="Tuning-Algorithm-Parameters"><a class="docs-heading-anchor" href="#Tuning-Algorithm-Parameters">Tuning Algorithm Parameters</a><a id="Tuning-Algorithm-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Tuning-Algorithm-Parameters" title="Permalink"></a></h2><h3 id="Maximum-Iterations"><a class="docs-heading-anchor" href="#Maximum-Iterations">Maximum Iterations</a><a id="Maximum-Iterations-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum-Iterations" title="Permalink"></a></h3><p><strong>How many iterations do you need?</strong></p><p>Typical ranges:</p><ul><li>CG/CGNR: 10-50 iterations</li><li>FISTA: 50-200 iterations</li><li>ADMM: 20-100 iterations</li></ul><p><strong>Strategy:</strong></p><pre><code class="language-julia hljs"># Start with more iterations to see convergence behavior
img = reconstruct(acq, reg, FISTA(maxit=200), verbose=true)
# Check output to see when convergence plateaus

# Then use fewer iterations in production
img = reconstruct(acq, reg, FISTA(maxit=80))</code></pre><h3 id="Convergence-Tolerance"><a class="docs-heading-anchor" href="#Convergence-Tolerance">Convergence Tolerance</a><a id="Convergence-Tolerance-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-Tolerance" title="Permalink"></a></h3><p>Controls early stopping:</p><pre><code class="language-julia hljs"># Stricter convergence
img = reconstruct(acq, reg, FISTA(maxit=200, tol=1e-6))

# Looser convergence (faster but less accurate)
img = reconstruct(acq, reg, FISTA(maxit=200, tol=1e-3))

# Disable early stopping
img = reconstruct(acq, reg, FISTA(maxit=100, tol=0))</code></pre><p><strong>Practical tip:</strong> Default <code>tol=1e-4</code> is usually good. Tighten to 1e-5 or 1e-6 if you need higher accuracy.</p><h3 id="Verbosity-and-Monitoring"><a class="docs-heading-anchor" href="#Verbosity-and-Monitoring">Verbosity and Monitoring</a><a id="Verbosity-and-Monitoring-1"></a><a class="docs-heading-anchor-permalink" href="#Verbosity-and-Monitoring" title="Permalink"></a></h3><p>Track convergence:</p><pre><code class="language-julia hljs"># Show progress every iteration
img = reconstruct(acq, reg, algorithm; verbose=true, freq=1)

# Show progress every 10 iterations
img = reconstruct(acq, reg, algorithm; verbose=true, freq=10)

# No output
img = reconstruct(acq, reg, algorithm; verbose=false)</code></pre><p><strong>What to look for:</strong></p><ul><li>Objective value decreasing</li><li>Changes becoming smaller</li><li>Reasonable convergence rate</li></ul><h2 id="Advanced-Usage"><a class="docs-heading-anchor" href="#Advanced-Usage">Advanced Usage</a><a id="Advanced-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Usage" title="Permalink"></a></h2><h3 id="Auto-Selecting-Multiple-Algorithms"><a class="docs-heading-anchor" href="#Auto-Selecting-Multiple-Algorithms">Auto-Selecting Multiple Algorithms</a><a id="Auto-Selecting-Multiple-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Auto-Selecting-Multiple-Algorithms" title="Permalink"></a></h3><p>Try multiple algorithms automatically:</p><pre><code class="language-julia hljs"># Provide tuple of algorithms to try
algorithms = (CG(maxit=20), FISTA(maxit=100), ADMM(maxit=50))
img = reconstruct(acq, reg, algorithms)

# Package automatically selects best for problem
# - CG tried first for smooth problems
# - FISTA for single regularizer
# - ADMM for multiple regularizers</code></pre><h3 id="Custom-Stopping-Criteria"><a class="docs-heading-anchor" href="#Custom-Stopping-Criteria">Custom Stopping Criteria</a><a id="Custom-Stopping-Criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Stopping-Criteria" title="Permalink"></a></h3><pre><code class="language-julia hljs">using ProximalAlgorithms

# Custom stopping function
function my_stop(iter, state)
    # Stop if objective doesn&#39;t change much
    if iter &gt; 1
        rel_change = abs(state.objective - prev_obj) / abs(prev_obj)
        return rel_change &lt; 1e-5
    end
    prev_obj = state.objective
    return false
end

# Use with low-level interface
# (requires working directly with ProximalAlgorithms.jl)</code></pre><h3 id="Warm-Starting"><a class="docs-heading-anchor" href="#Warm-Starting">Warm Starting</a><a id="Warm-Starting-1"></a><a class="docs-heading-anchor-permalink" href="#Warm-Starting" title="Permalink"></a></h3><p>Use previous solution as initialization:</p><pre><code class="language-julia hljs"># First reconstruction
img1 = reconstruct(acq, L1Wavelet2D(5e-3))

# Use as initialization for refined reconstruction
img2 = reconstruct(acq, L1Wavelet2D(3e-3); x₀=img1)</code></pre><p><strong>When useful:</strong></p><ul><li>Parameter sweeps</li><li>Iterative refinement</li><li>Multi-stage reconstruction</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../regularization/">« Regularization</a><a class="docs-footer-nextpage" href="../nameddims/">Named Dimensions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Tuesday 18 November 2025 20:18">Tuesday 18 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
