<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Regularization ¬∑ MriReconstructionToolbox.jl</title><meta name="title" content="Regularization ¬∑ MriReconstructionToolbox.jl"/><meta property="og:title" content="Regularization ¬∑ MriReconstructionToolbox.jl"/><meta property="twitter:title" content="Regularization ¬∑ MriReconstructionToolbox.jl"/><meta name="description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="og:description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="twitter:description" content="Documentation for MriReconstructionToolbox.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="MriReconstructionToolbox.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="MriReconstructionToolbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MriReconstructionToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../theory/">Theoretical Background</a></li><li><span class="tocitem">High-level Interface</span><ul><li><a class="tocitem" href="../acquisition_info/">AcquisitionInfo</a></li><li><a class="tocitem" href="../simulation/">Simulation Tools</a></li><li><a class="tocitem" href="../reconstruction/">Reconstruction</a></li><li class="is-active"><a class="tocitem" href>Regularization</a><ul class="internal"><li><a class="tocitem" href="#Why-Regularization?"><span>Why Regularization?</span></a></li><li><a class="tocitem" href="#Understanding-the-Math"><span>Understanding the Math</span></a></li><li><a class="tocitem" href="#Available-Regularization-Methods"><span>Available Regularization Methods</span></a></li><li><a class="tocitem" href="#Combining-Multiple-Regularizers"><span>Combining Multiple Regularizers</span></a></li><li><a class="tocitem" href="#Choosing-Regularization-Parameters"><span>Choosing Regularization Parameters</span></a></li></ul></li><li><a class="tocitem" href="../algorithms/">Optimization Algorithms</a></li><li><a class="tocitem" href="../nameddims/">Named Dimensions</a></li><li><a class="tocitem" href="../decomposition/">Problem Decomposition</a></li></ul></li><li><span class="tocitem">Low-Level Interface</span><ul><li><a class="tocitem" href="../../low-level/operators/">MRI Operators</a></li><li><a class="tocitem" href="../../low-level/custom_reconstruction/">Custom Reconstruction</a></li><li><a class="tocitem" href="../../low-level/abstract_operators/">AbstractOperators.jl</a></li><li><a class="tocitem" href="../../low-level/proximal_operators/">ProximalOperators.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">High-level Interface</a></li><li class="is-active"><a href>Regularization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Regularization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/master/docs/src/high-level/regularization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Regularization"><a class="docs-heading-anchor" href="#Regularization">Regularization</a><a id="Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Regularization" title="Permalink"></a></h1><p>Regularization is essential for reconstructing high-quality images from undersampled k-space data. This page explains the available regularization methods and how to use them.</p><h2 id="Why-Regularization?"><a class="docs-heading-anchor" href="#Why-Regularization?">Why Regularization?</a><a id="Why-Regularization?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Regularization?" title="Permalink"></a></h2><p>When k-space is undersampled (as in compressed sensing or parallel imaging), the reconstruction problem becomes <strong>ill-posed</strong> - there are many possible images that could have produced the observed data. Regularization adds prior knowledge about what &quot;good&quot; images look like to guide the reconstruction toward a unique, high-quality solution.</p><h2 id="Understanding-the-Math"><a class="docs-heading-anchor" href="#Understanding-the-Math">Understanding the Math</a><a id="Understanding-the-Math-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-the-Math" title="Permalink"></a></h2><p>For those interested in the mathematical details, the reconstruction solves:</p><pre><code class="nohighlight hljs">minimize  (1/2)‚ÄñE¬∑x - y‚Äñ‚ÇÇ¬≤ + ‚àë·µ¢ Œª·µ¢¬∑R·µ¢(x)</code></pre><p>Where:</p><ul><li><code>E</code> is the encoding operator (Fourier + sensitivity + subsampling)</li><li><code>x</code> is the image to reconstruct</li><li><code>y</code> is the observed k-space data</li><li><code>‚ÄñE¬∑x - y‚Äñ‚ÇÇ¬≤</code> is the data fidelity term</li><li><code>R·µ¢(x)</code> are the regularization terms</li><li><code>Œª·µ¢</code> are the regularization parameters</li></ul><p>The first term ensures the reconstruction is consistent with observed data. The regularization terms encode prior knowledge about image properties.</p><h2 id="Available-Regularization-Methods"><a class="docs-heading-anchor" href="#Available-Regularization-Methods">Available Regularization Methods</a><a id="Available-Regularization-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Regularization-Methods" title="Permalink"></a></h2><p>The code snippets in the following sections assume that <code>MriReconstructionToolbox</code> and <code>MIRTjim</code> are already imported. <code>MIRTjim</code> is a convenience wrapper around <code>Plots.jl</code> for displaying multidimensional images. Also, assume you have an <code>AcquisitionInfo</code> object <code>acq</code> representing your k-space data and acquisition settings for simulated Shepp-Logan phantom:</p><pre><code class="language-julia hljs">using MriReconstructionToolbox
using MIRTjim: jim

# Simulate 2D acquisition
x = shepp_logan(128, 128)
x_noisy = x + 0.02f0 * randn(ComplexF32, 128, 128)
smaps = coil_sensitivities(128, 128, 8)
pdf = VariableDensitySampling(PolynomialDistribution(3), 4.0, 0.05)
pattern = create_sampling_pattern(pdf, (128, 128))
acq_full = AcquisitionInfo(
    is3D=false,
    image_size=(128, 128),
    subsampling=pattern,
    sensitivity_maps=smaps
)
data = simulate_acquisition(x_noisy, acq_full)

# Simulate 3D acquisition
x3d = shepp_logan(64, 64, 32)
smaps3d = coil_sensitivities(64, 64, 32, 8)
subsampling3d = create_sampling_pattern(
    VariableDensitySampling(PolynomialDistribution(3), 4.0, 0.05),
    (64, 64, 32)
)
acq3d = AcquisitionInfo(
    image_size=(64, 64, 32),
    sensitivity_maps=smaps3d,
    subsampling=subsampling3d,
)
data3d = simulate_acquisition(x3d, acq3d)

jim(x3d; title=&quot;Shepp-Logan Phantom (3D)&quot;, size=(800,400))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GKS: cannot open display - headless operation mode active</code></pre><p><img src="../shepp_logan_phantom_3d.png" alt="shepp_logan_phantom_3d.png"/></p><h3 id="Image-Domain-Regularization"><a class="docs-heading-anchor" href="#Image-Domain-Regularization">Image Domain Regularization</a><a id="Image-Domain-Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Image-Domain-Regularization" title="Permalink"></a></h3><h4 id="Tikhonov-(L2)-Regularization"><a class="docs-heading-anchor" href="#Tikhonov-(L2)-Regularization">Tikhonov (L2) Regularization</a><a id="Tikhonov-(L2)-Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Tikhonov-(L2)-Regularization" title="Permalink"></a></h4><p>The simplest form of regularization, penalizing large pixel values:</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.Tikhonov"><a class="docstring-binding" href="#MriReconstructionToolbox.Tikhonov"><code>MriReconstructionToolbox.Tikhonov</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Tikhonov(Œª)</code></pre><p>Create a Tikhonov regularization term with parameter <code>Œª</code>.</p><p>The regularization term is given by <code>Œª¬≤‚Äñx‚Äñ‚ÇÇ¬≤</code>, or <code>‚ÄñŒì .* x‚Äñ‚ÇÇ¬≤</code> if <code>Œª</code> is an array <code>Œì</code> of the same size as <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Œª</code>: Regularization parameter, can be a scalar or an array of the same size as <code>x</code>.</li></ul><p><strong>Notes</strong></p><ul><li>This regularization term is also known as L2 regularization or ridge regression.</li><li>The squared parameter <code>Œª¬≤</code> is used in the formulation to align with common conventions in</li></ul><p>Tikhonov regularization literature.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/regularization/image_domain_reg.jl#L1-L15">source</a></div></details></article><p><strong>When to use:</strong></p><ul><li>Noise reduction without strong assumptions about image structure</li><li>As a baseline for comparison with other methods, especially for parallel imaging</li><li>Fast and simple regularization (it is computationally cheap and can be optimized with Conjugate Gradient)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">img‚ÇÅ = reconstruct(data, Tikhonov(1e-1), verbose=false)
img‚ÇÇ = reconstruct(data, Tikhonov(1e-6), verbose=false)
p1 = jim(img‚ÇÅ; title=&quot;Tikhonov Œª=1e-1&quot;)
p2 = jim(img‚ÇÇ; title=&quot;Tikhonov Œª=1e-6&quot;)
jim(p1, p2; layout=(1,2), size=(800,400))</code></pre><p><img src="../tikhonov_regularization.png" alt="tikhonov_regularization.png"/></p><h4 id="L1-Regularization"><a class="docs-heading-anchor" href="#L1-Regularization">L1 Regularization</a><a id="L1-Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#L1-Regularization" title="Permalink"></a></h4><p>Promotes sparse images (many pixels close to zero):</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.L1Image"><a class="docstring-binding" href="#MriReconstructionToolbox.L1Image"><code>MriReconstructionToolbox.L1Image</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">L1Image(Œª)</code></pre><p>Create a L1 image regularization term with parameter <code>Œª</code>. The regularization term is given by <code>Œª‚Äñx‚Äñ‚ÇÅ</code>, or <code>‚ÄñŒì .* x‚Äñ‚ÇÅ</code> if <code>Œª</code> is an array <code>Œì</code> of the same size as <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Œª</code>: Regularization parameter, can be a scalar or an array of the same size as <code>x</code>.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/regularization/image_domain_reg.jl#L42-L50">source</a></div></details></article><p><strong>When to use:</strong></p><ul><li>Images that are naturally sparse (e.g., angiography) and you want to suppress small values</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">img‚ÇÅ = reconstruct(data, L1Image(1e-2), verbose=false)
img‚ÇÇ = reconstruct(data, L1Image(1e-5), verbose=false)
p1 = jim(img‚ÇÅ; title=&quot;L1Image Œª=1e-2&quot;)
p2 = jim(img‚ÇÇ; title=&quot;L1Image Œª=1e-5&quot;)
jim(p1, p2; layout=(1,2), size=(800,400))</code></pre><p><img src="../l1image_regularization.png" alt="l1image_regularization.png"/></p><h3 id="Wavelet-Domain-Regularization"><a class="docs-heading-anchor" href="#Wavelet-Domain-Regularization">Wavelet Domain Regularization</a><a id="Wavelet-Domain-Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Wavelet-Domain-Regularization" title="Permalink"></a></h3><h4 id="2D-Wavelet-Sparsity"><a class="docs-heading-anchor" href="#2D-Wavelet-Sparsity">2D Wavelet Sparsity</a><a id="2D-Wavelet-Sparsity-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Wavelet-Sparsity" title="Permalink"></a></h4><p>Promotes sparsity in the wavelet domain:</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.L1Wavelet2D"><a class="docstring-binding" href="#MriReconstructionToolbox.L1Wavelet2D"><code>MriReconstructionToolbox.L1Wavelet2D</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">L1Wavelet2D(Œª; wavelet=WT.db2, levels=2)</code></pre><p>Create a L1 wavelet regularization term for 2D images with parameter <code>Œª</code>. The regularization term is given by <code>Œª‚Äñùí≤x‚Äñ‚ÇÅ</code>, where <code>ùí≤</code> is the 2D wavelet transform operator. The <code>wavelet</code> and <code>levels</code> parameters control the type of wavelet and the number of decomposition levels used in the transform.</p><p><strong>Arguments</strong></p><ul><li><code>Œª</code>: Regularization parameter, can be a scalar or an array of the same size as <code>x</code>.</li><li><code>wavelet</code>: (optional) Type of wavelet to use, specified as a <code>WT.Wavelet</code>. Default is <code>WT.db2</code> (Daubechies 2).</li><li><code>levels</code>: (optional) Number of decomposition levels in the wavelet transform. Default is <code>2</code>.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/regularization/wavelet_reg.jl#L1-L12">source</a></div></details></article><p><strong>When to use:</strong></p><ul><li>Natural images with structure at multiple scales</li><li>Most MRI applications (anatomy has multi-scale features)</li><li>Standard compressed sensing reconstruction</li></ul><p><strong>Parameters:</strong></p><ul><li><code>Œª</code>: Regularization strength (try 1e-3 to 1e-2)</li><li><code>wavelet</code>: Wavelet type (default: Daubechies, also try Haar, etc.)</li><li><code>levels</code>: Number of decomposition levels (default: 4)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">reg = L1Wavelet2D(1e-3)
example_img = rand(ComplexF32, 128, 128)
op = get_operator(reg, example_img)
transformed = op * x_noisy
p1 = jim(transformed; title=&quot;Wavelet Coefficients&quot;)
img = reconstruct(data, reg, verbose=false)
p2 = jim(img; title=&quot;L1Wavelet2D Reconstruction&quot;)
jim(p1, p2; layout=(1,2), size=(800,400))</code></pre><p><img src="../l1wavelet2d_regularization.png" alt="l1wavelet2d_regularization.png"/></p><p><strong>Options for <code>L1Wavelet2D</code>:</strong></p><ul><li><code>wavelet</code>: Specify wavelet type (e.g., <code>WT.haar</code>, <code>WT.db4</code>)</li><li><code>levels</code>: Number of decomposition levels (default: 4)</li></ul><pre><code class="language-julia hljs">reg_haar = L1Wavelet2D(1e-2; wavelet=WT.haar)
op_haar = get_operator(reg_haar, example_img)
transformed_haar = op_haar * x_noisy
img_haar = reconstruct(data, reg_haar, verbose=false)
p1 = jim(transformed_haar; title=&quot;Haar Coefficients&quot;)
p2 = jim(img_haar; title=&quot;Haar Reconstruction&quot;)

reg_level8 = L1Wavelet2D(1e-3; levels=8)
op_level8 = get_operator(reg_level8, example_img)
transformed_level8 = op_level8 * x_noisy
img_level8 = reconstruct(data, reg_level8, verbose=false)
p3 = jim(transformed_level8; title=&quot;Level 8 Coefficients&quot;)
p4 = jim(img_level8; title=&quot;Level 8 Reconstruction&quot;)
jim(p1, p2, p3, p4; layout=(2,2), size=(800,700))</code></pre><p><img src="../l1wavelet2d_options.png" alt="l1wavelet2d_options.png"/></p><h4 id="3D-Wavelet-Sparsity"><a class="docs-heading-anchor" href="#3D-Wavelet-Sparsity">3D Wavelet Sparsity</a><a id="3D-Wavelet-Sparsity-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Wavelet-Sparsity" title="Permalink"></a></h4><p>For volumetric / multislice data, promotes sparsity in 3D wavelet domain:</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.L1Wavelet3D"><a class="docstring-binding" href="#MriReconstructionToolbox.L1Wavelet3D"><code>MriReconstructionToolbox.L1Wavelet3D</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">L1Wavelet3D(Œª; wavelet=WT.db2, levels=2)</code></pre><p>Create a L1 wavelet regularization term for 3D images with parameter <code>Œª</code>. The regularization term is given by <code>Œª‚Äñùí≤x‚Äñ‚ÇÅ</code>, where <code>ùí≤</code> is the 3D wavelet transform operator. The <code>wavelet</code> and <code>levels</code> parameters control the type of wavelet and the number of decomposition levels used in the transform.</p><p><strong>Arguments</strong></p><ul><li><code>Œª</code>: Regularization parameter, can be a scalar or an array of the same size as <code>x</code>.</li><li><code>wavelet</code>: (optional) Type of wavelet to use, specified as a <code>WT.Wavelet</code>. Default is <code>WT.db2</code> (Daubechies 2).</li><li><code>levels</code>: (optional) Number of decomposition levels in the wavelet transform. Default is <code>2</code>.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/regularization/wavelet_reg.jl#L51-L62">source</a></div></details></article><p><strong>When to use:</strong></p><ul><li>3D acquisitions or multi-slice 2D data</li><li>When you want to exploit 3D structure</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">reg3d = L1Wavelet3D(1e-3)

op = get_operator(reg3d, rand(ComplexF32, 64, 64, 32))
transformed = op * x3d
jim(abs.(transformed); title=&quot;3D Wavelet Coefficients&quot;, size=(800,400))</code></pre><p><img src="../l1wavelet3d_coefficients.png" alt="l1wavelet3d_coefficients.png"/></p><h3 id="Total-Variation"><a class="docs-heading-anchor" href="#Total-Variation">Total Variation</a><a id="Total-Variation-1"></a><a class="docs-heading-anchor-permalink" href="#Total-Variation" title="Permalink"></a></h3><h4 id="2D-Total-Variation"><a class="docs-heading-anchor" href="#2D-Total-Variation">2D Total Variation</a><a id="2D-Total-Variation-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Total-Variation" title="Permalink"></a></h4><p>Promotes piecewise-constant images by penalizing rapid changes:</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.TotalVariation2D"><a class="docstring-binding" href="#MriReconstructionToolbox.TotalVariation2D"><code>MriReconstructionToolbox.TotalVariation2D</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">TotalVariation2D(Œª)</code></pre><p>Create a Total Variation regularization term for 2D images with parameter <code>Œª</code>. The regularization term is given by <code>Œª‚ÄñŒîx‚Äñ_{2,1}</code>, where <code>Œî</code> is the 2D finite difference operator computing gradients along the two spatial dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>Œª</code>: Regularization parameter, must be a scalar.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/regularization/total_variation_reg.jl#L1-L9">source</a></div></details></article><p><strong>When to use:</strong></p><ul><li>Images with sharp edges and flat regions</li><li>Brain imaging with gray/white matter boundaries</li><li>When you want strong edge preservation</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">reg = TotalVariation2D(1e-3)
op = get_operator(reg, example_img)
transformed = op * x_noisy
img = reconstruct(data, reg, verbose=false)
p1 = jim(transformed[:,:,1]; title=&quot;Œîx Coefficients&quot;)
p2 = jim(transformed[:,:,2]; title=&quot;Œîy Coefficients&quot;)
p3 = jim(img; title=&quot;TotalVariation2D Reconstruction&quot;)
jim(p1, p2, p3; layout=(1, 3), size=(900,250))</code></pre><p><img src="../totalvariation2d_coefficients.png" alt="totalvariation2d_coefficients.png"/></p><p><strong>Practical tip:</strong> TV can create a &quot;cartoon-like&quot; appearance. Use lower Œª values (1e-4 to 5e-3) to preserve texture.</p><h4 id="3D-Total-Variation"><a class="docs-heading-anchor" href="#3D-Total-Variation">3D Total Variation</a><a id="3D-Total-Variation-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Total-Variation" title="Permalink"></a></h4><p>For volumetric / multislice data, promotes piecewise-constant structure in 3D:</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.TotalVariation3D"><a class="docstring-binding" href="#MriReconstructionToolbox.TotalVariation3D"><code>MriReconstructionToolbox.TotalVariation3D</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">TotalVariation3D(Œª)</code></pre><p>Create a Total Variation regularization term for 3D images with parameter <code>Œª</code>. The regularization term is given by <code>Œª‚ÄñŒîx‚Äñ_{2,1}</code>, where <code>Œî</code> is the 3D finite difference operator computing gradients along the three spatial dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>Œª</code>: Regularization parameter, must be a scalar.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/regularization/total_variation_reg.jl#L35-L43">source</a></div></details></article><h3 id="Temporal-Regularization"><a class="docs-heading-anchor" href="#Temporal-Regularization">Temporal Regularization</a><a id="Temporal-Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal-Regularization" title="Permalink"></a></h3><h4 id="Temporal-Fourier-Sparsity"><a class="docs-heading-anchor" href="#Temporal-Fourier-Sparsity">Temporal Fourier Sparsity</a><a id="Temporal-Fourier-Sparsity-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal-Fourier-Sparsity" title="Permalink"></a></h4><p>For dynamic imaging, promotes sparsity in the temporal Fourier domain:</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.TemporalFourier"><a class="docstring-binding" href="#MriReconstructionToolbox.TemporalFourier"><code>MriReconstructionToolbox.TemporalFourier</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">TemporalFourier(Œª; time_dim=nothing)</code></pre><p>Create a temporal Fourier regularization term with parameter <code>Œª</code>. The regularization term is given by <code>Œª‚Äñùìï‚Çú{x}‚Äñ‚ÇÅ</code>, where <code>ùìï‚Çú</code> is the discrete Fourier transform along the temporal dimension specified by <code>time_dim</code>. If <code>time_dim</code> is not provided, it will be inferred as the dimension named <code>:time</code> if <code>x</code> is a <code>NamedDimsArray</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Œª</code>: Regularization parameter, can be a scalar or an array of the same size as <code>x</code>.</li><li><code>time_dim</code>: (optional) Dimension along which to apply the Fourier transform. Can be an <code>Integer</code> (1-based index)</li></ul><p>or a <code>Symbol</code> (dimension name). If not provided, it will be inferred as the dimension named <code>:time</code> if <code>x</code> is a <code>NamedDimsArray</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/regularization/temporal_fourier_reg.jl#L1-L12">source</a></div></details></article><p><strong>When to use:</strong></p><ul><li>Dynamic or cine imaging</li><li>Cardiac MRI</li><li>DCE-MRI (dynamic contrast enhanced)</li><li>When motion is periodic or smoothly varying</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">img = reconstruct(acq, TemporalFourier(1e-2, time_dim=4))</code></pre><p><strong>Practical tip:</strong> This works best when temporal changes are smooth or periodic. For irregular motion, consider low-rank methods instead.</p><h3 id="Low-Rank-Regularization"><a class="docs-heading-anchor" href="#Low-Rank-Regularization">Low-Rank Regularization</a><a id="Low-Rank-Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Low-Rank-Regularization" title="Permalink"></a></h3><h4 id="Nuclear-Norm"><a class="docs-heading-anchor" href="#Nuclear-Norm">Nuclear Norm</a><a id="Nuclear-Norm-1"></a><a class="docs-heading-anchor-permalink" href="#Nuclear-Norm" title="Permalink"></a></h4><p>Promotes low-rank structure in dynamic data:</p><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.LowRank"><a class="docstring-binding" href="#MriReconstructionToolbox.LowRank"><code>MriReconstructionToolbox.LowRank</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LowRank(Œª; time_dim=nothing)</code></pre><p>Create a low-rank regularization term with parameter <code>Œª</code>. The regularization term is given by <code>Œª‚Äñùìß‚Äñ_*</code>, where <code>ùìß</code> is the Casorati matrix formed by unfolding the input variable <code>x</code> along the temporal dimension specified by <code>time_dim</code>. If <code>time_dim</code> is not provided, it will be inferred as the dimension named <code>:time</code> if <code>x</code> is a <code>NamedDimsArray</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Œª</code>: Regularization parameter, can be a scalar or an array of the same size as <code>x</code>.</li><li><code>time_dim</code>: (optional) Dimension along which to form the Casorati matrix. Can be an <code>Integer</code> (1-based index)</li></ul><p>or a <code>Symbol</code> (dimension name). If not provided, it will be inferred as the dimension named <code>:time</code> if <code>x</code> is a <code>NamedDimsArray</code>.</p><p><strong>Notes:</strong></p><ul><li>The nuclear norm <code>‚Äñùìß‚Äñ_*</code> is the sum of the singular values of the matrix <code>ùìß</code>.</li><li>The Casorati matrix is formed by reshaping <code>x</code> such that the specified <code>time_dim</code> becomes the second dimension,</li></ul><p>and all other dimensions before it are reshaped into columns (first dimension), while dimensions after it are treated as batch dimensions.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/regularization/low_rank_reg.jl#L1-L18">source</a></div></details></article><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.RankLimit"><a class="docstring-binding" href="#MriReconstructionToolbox.RankLimit"><code>MriReconstructionToolbox.RankLimit</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">RankLimit(max_rank; time_dim=nothing)</code></pre><p>Create a rank limit regularization term that constrains the rank of the Casorati matrix formed by unfolding the input variable <code>x</code> along the temporal dimension specified by <code>time_dim</code>. The rank of the Casorati matrix will be limited to <code>max_rank</code>. If <code>time_dim</code> is not provided, it will be inferred as the dimension named <code>:time</code> if <code>x</code> is a <code>NamedDimsArray</code>.</p><p><strong>Arguments</strong></p><ul><li><code>max_rank</code>: Maximum allowed rank for the Casorati matrix.</li><li><code>time_dim</code>: (optional) Dimension along which to form the Casorati matrix. Can be an <code>Integer</code> (1-based index)</li></ul><p>or a <code>Symbol</code> (dimension name). If not provided, it will be inferred as the dimension named <code>:time</code> if <code>x</code> is a <code>NamedDimsArray</code>.</p><p><strong>Notes:</strong></p><ul><li>The nuclear norm <code>‚Äñùìß‚Äñ_*</code> is the sum of the singular values of the matrix <code>ùìß</code>.</li><li>The Casorati matrix is formed by reshaping <code>x</code> such that the specified <code>time_dim</code> becomes the second dimension,</li></ul><p>and all other dimensions before it are reshaped into columns (first dimension), while dimensions after it are treated as batch dimensions.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/regularization/low_rank_reg.jl#L28-L46">source</a></div></details></article><p><strong>When to use:</strong></p><ul><li>Dynamic imaging with temporal correlations</li><li>Background suppression in DCE-MRI</li><li>Data with strong spatiotemporal correlations</li><li>When images share common features across time</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Dynamic series with low-rank structure
img = reconstruct(acq_dynamic, LowRank(1e-1))</code></pre><p><strong>Practical tip:</strong> Low-rank methods can be computationally expensive. Use for datasets where temporal correlations are strong.</p><h2 id="Combining-Multiple-Regularizers"><a class="docs-heading-anchor" href="#Combining-Multiple-Regularizers">Combining Multiple Regularizers</a><a id="Combining-Multiple-Regularizers-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-Multiple-Regularizers" title="Permalink"></a></h2><p>You can combine multiple regularization terms to exploit different image properties simultaneously:</p><pre><code class="language-julia hljs"># Comprehensive regularization for dynamic imaging
reg = (
    L1Wavelet2D(5e-3),      # Spatial sparsity
    TotalVariation2D(1e-3),  # Edge preservation
    TemporalFourier(2e-2)    # Temporal smoothness
)
img = reconstruct(acq_dynamic, reg)</code></pre><p><strong>When to combine:</strong></p><ul><li>Wavelet + TV: Exploit both multi-scale structure and edge preservation</li><li>Spatial + Temporal: Regularize both space and time dimensions</li><li>Multiple spatial regularizers: When images have complex structure</li></ul><h2 id="Choosing-Regularization-Parameters"><a class="docs-heading-anchor" href="#Choosing-Regularization-Parameters">Choosing Regularization Parameters</a><a id="Choosing-Regularization-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-Regularization-Parameters" title="Permalink"></a></h2><p>The regularization parameter Œª controls the trade-off between data fidelity and regularization:</p><ul><li><strong>Too small (Œª ‚Üí 0)</strong>: Noisy, artifacts remain</li><li><strong>Too large (Œª ‚Üí ‚àû)</strong>: Over-smoothed, loss of detail</li><li><strong>Just right</strong>: Balance between noise/artifact suppression and detail preservation</li></ul><h3 id="Practical-Guidelines"><a class="docs-heading-anchor" href="#Practical-Guidelines">Practical Guidelines</a><a id="Practical-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-Guidelines" title="Permalink"></a></h3><p><strong>Starting values by regularization type:</strong></p><ul><li>Tikhonov: <code>1e-5</code> to <code>1e-3</code></li><li>L1Image: <code>1e-4</code> to <code>1e-2</code></li><li>L1Wavelet: <code>1e-3</code> to <code>1e-2</code></li><li>TotalVariation: <code>1e-4</code> to <code>5e-3</code></li><li>TemporalFourier: <code>1e-2</code> to <code>1e-1</code></li><li>LowRank: <code>1e-2</code> to <code>1</code></li></ul><p><strong>Adjustment strategy:</strong></p><ol><li>Start with the suggested value</li><li>If too noisy/aliased ‚Üí increase Œª</li><li>If too smooth/blurry ‚Üí decrease Œª</li><li>Typical range: adjust by factors of 2-5</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reconstruction/">¬´ Reconstruction</a><a class="docs-footer-nextpage" href="../algorithms/">Optimization Algorithms ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Tuesday 18 November 2025 23:46">Tuesday 18 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
