<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reconstruction ¬∑ MriReconstructionToolbox.jl</title><meta name="title" content="Reconstruction ¬∑ MriReconstructionToolbox.jl"/><meta property="og:title" content="Reconstruction ¬∑ MriReconstructionToolbox.jl"/><meta property="twitter:title" content="Reconstruction ¬∑ MriReconstructionToolbox.jl"/><meta name="description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="og:description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="twitter:description" content="Documentation for MriReconstructionToolbox.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="MriReconstructionToolbox.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="MriReconstructionToolbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MriReconstructionToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../theory/">Theoretical Background</a></li><li><span class="tocitem">High-level Interface</span><ul><li><a class="tocitem" href="../acquisition_info/">AcquisitionInfo</a></li><li><a class="tocitem" href="../simulation/">Simulation Tools</a></li><li class="is-active"><a class="tocitem" href>Reconstruction</a><ul class="internal"><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Reconstruction-Workflow"><span>Reconstruction Workflow</span></a></li><li><a class="tocitem" href="#Configuration-Control"><span>Configuration Control</span></a></li><li><a class="tocitem" href="#Algorithm-Selection"><span>Algorithm Selection</span></a></li><li><a class="tocitem" href="#Multiple-Regularization-Terms"><span>Multiple Regularization Terms</span></a></li><li><a class="tocitem" href="#Initial-Guess"><span>Initial Guess</span></a></li><li><a class="tocitem" href="#Advanced-Features"><span>Advanced Features</span></a></li><li><a class="tocitem" href="#Problem-Decomposition"><span>Problem Decomposition</span></a></li><li><a class="tocitem" href="#Custom-Progress-Logging"><span>Custom Progress Logging</span></a></li><li><a class="tocitem" href="#Named-Dimensions-Support"><span>Named Dimensions Support</span></a></li></ul></li><li><a class="tocitem" href="../regularization/">Regularization</a></li><li><a class="tocitem" href="../algorithms/">Optimization Algorithms</a></li><li><a class="tocitem" href="../nameddims/">Named Dimensions</a></li><li><a class="tocitem" href="../decomposition/">Problem Decomposition</a></li></ul></li><li><span class="tocitem">Low-Level Interface</span><ul><li><a class="tocitem" href="../../low-level/operators/">MRI Operators</a></li><li><a class="tocitem" href="../../low-level/custom_reconstruction/">Custom Reconstruction</a></li><li><a class="tocitem" href="../../low-level/abstract_operators/">AbstractOperators.jl</a></li><li><a class="tocitem" href="../../low-level/proximal_operators/">ProximalOperators.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">High-level Interface</a></li><li class="is-active"><a href>Reconstruction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reconstruction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/master/docs/src/high-level/reconstruction.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="reconstruction"><a class="docs-heading-anchor" href="#reconstruction">Image Reconstruction</a><a id="reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#reconstruction" title="Permalink"></a></h1><p>The <code>reconstruct</code> function is the primary high-level interface for MRI image reconstruction from k-space data. It handles both direct (adjoint-based) and iterative reconstruction with regularization, with automatic problem decomposition and performance optimization.</p><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.reconstruct"><a class="docstring-binding" href="#MriReconstructionToolbox.reconstruct"><code>MriReconstructionToolbox.reconstruct</code></a> ‚Äî <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">reconstruct(
	acq_data::AcquisitionInfo;
	regularization::Union{Regularization, Tuple{Vararg{Regularization}}}=(),
	algorithm=(CG(;maxit=20), FISTA(;maxit=50), ADMM(;maxit=100)),
	threaded::Bool=true)</code></pre><p>Performs MRI reconstruction from k-space data using the specified regularization, and optimization algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>acq_data::AcquisitionInfo</code>: The acquisition information containing k-space data, sensitivity maps, and other parameters.</li><li><code>regularization::Union{Regularization, Tuple{Vararg{Regularization}}}</code>: The regularization term(s) to use (default is no regularization).</li><li><code>algorithm</code>: The optimization algorithm(s) to use (default is a tuple of CG, FISTA, and ADMM with specified max iterations).</li><li><code>x‚ÇÄ::Union{Nothing,AbstractArray}=nothing</code>: Optional initial guess for the image (default is ùíú&#39; * y).</li><li><code>normalization::Normalization = BartScaling()</code>: scaling applied to operators/data</li><li><code>tol::Float64 = 1e-4</code>: stopping tolerance for iterative algorithms</li><li><code>maxit::Int = 100</code>: maximum iterations for the chosen solver</li><li><code>freq::Union{Nothing,Int} = nothing</code>: progress print frequency (iterations)</li><li><code>verbose::Bool = true</code>: enable/disable logging output</li><li><code>threaded::Bool = (Threads.nthreads() &gt; 1)</code>: enable threaded execution when available</li><li><code>exact_opnorm::Bool = false</code>: use exact operator norm for stepsize estimation</li><li><code>decomposition_executor::Union{Nothing,ReconstructionExecutor} = nothing</code>: override executor for decomposition</li><li><code>disable_inverse_scale_output::Bool = false</code>: skip rescaling the final output</li><li><code>disable_normalop_optimization::Bool = false</code>: disable normal-operator optimizations</li><li><code>disable_problem_decomposition::Bool = false</code>: disable automatic problem decomposition</li><li><code>disable_operator_normalization::Bool = false</code>: disable operator normalization</li><li><code>printfunc::Function = println</code>: custom logging function</li></ul><p><strong>Returns</strong></p><ul><li>The reconstructed image (NamedDimsArray if input is NamedDimsArray, otherwise standard Array).</li></ul><p><strong>Notes</strong></p><p><strong>Normalop Optimization</strong></p><ul><li>If <code>disable_normalop_optimization</code> is false, the function uses <code>normalop_ls</code> for efficiency when appropriate.</li><li>It should not change the result of the reconstruction, but it changes the reported value of consistency term.</li><li>To understand this, one can think of the optimization problem as minimizing</li></ul><p><code>|| ùíú*x - y ||_2^2 + Œ£ R_i(x)</code>, where <code>|| ùíú*x - y ||_2^2</code> is the consistency term, <code>R_i</code> are the regularization terms, <code>ùíú</code> is the encoding operator, and <code>y</code> is the k-space data.</p><ul><li>When normalop optimization is disabled, the reported value of <code>f(x)</code> is exactly the consistency term</li></ul><p><code>|| ùíú*x - y ||_2^2</code>. When enabled, it exploits the fact that <code>‚àáf(x) = ùíú&#39;*(ùíú*x - y) = ùíú&#39;*ùíú*x - ùíú&#39;*y</code>, and usually there exists an optimized operator for <code>ùíú&#39;*ùíú</code>. Therefore, it computes <code>f(x)</code> as <code>|| ùíú&#39;*ùíú*x - ùíú&#39;*y ||_2^2</code>, which leads to the same result, but with potentially improved efficiency.</p><p><strong>Problem Decomposition</strong></p><ul><li>If <code>disable_problem_decomposition</code> is false, the function automatically decomposes the reconstruction problem</li></ul><p>over batch dimensions of the image that are not affected by the Fourier transform or regularization terms.</p><ul><li>E.g., for a 3D+t acquisition with no regularization, the reconstruction is decomposed over the time dimension,</li></ul><p>and each 3D volume is reconstructed independently.</p><ul><li>This can significantly speed up the reconstruction when multiple CPU cores are available. Usually, this leads</li></ul><p>to better resource utilization and faster overall reconstruction times, but is useful to disable for debug purposes.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/reconstruction/reconstruct.jl#L1-L55">source</a></div></details></article><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.Config"><a class="docstring-binding" href="#MriReconstructionToolbox.Config"><code>MriReconstructionToolbox.Config</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">Config(; kwargs...)</code></pre><p>Global reconstruction configuration used by <code>reconstruct</code> and internal routines. It centralizes iteration control, tolerances, normalization, threading, and automatic problem decomposition behavior.</p><p>Fields (with defaults):</p><ul><li>normalization::Normalization = BartScaling() ‚Äî scaling applied to operators/data</li><li>tol::Float64 = 1e-4 ‚Äî stopping tolerance for iterative algorithms</li><li>maxit::Int = 100 ‚Äî maximum iterations for the chosen solver</li><li>freq::Union{Nothing,Int} = nothing ‚Äî progress print frequency (iterations)</li><li>verbose::Bool = true ‚Äî enable/disable logging output</li><li>threaded::Bool = (Threads.nthreads() &gt; 1) ‚Äî enable threaded execution when available</li><li>exact_opnorm::Bool = false ‚Äî use exact operator norm for stepsize estimation</li><li>decomposition_executor::Union{Nothing,ReconstructionExecutor} = nothing ‚Äî override executor for decomposition</li><li>disable<em>inverse</em>scale_output::Bool = false ‚Äî skip rescaling the final output</li><li>disable<em>normalop</em>optimization::Bool = false ‚Äî disable normal-operator optimizations</li><li>disable<em>problem</em>decomposition::Bool = false ‚Äî disable automatic problem decomposition</li><li>disable<em>operator</em>normalization::Bool = false ‚Äî disable operator normalization</li><li>printfunc::Function = println ‚Äî custom logging function</li></ul><p>Constructors:</p><ul><li><code>Config(; kwargs...)</code> ‚Äî build from defaults, override selected fields</li><li><code>Config(config::Config; kwargs...)</code> ‚Äî extend an existing config overriding selected fields</li></ul><p>Examples</p><pre><code class="language-julia hljs">using MriReconstructionToolbox

# Default config
conf = Config()

# Custom tolerances and iterations
conf = Config(; tol=1e-5, maxit=200, verbose=false)

# Extend an existing config
conf2 = Config(conf; maxit=50, disable_problem_decomposition=true)

# Use with reconstruct (keywords still override config fields)
xÃÇ = reconstruct(acq; config=conf2, maxit=25)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/reconstruction/config.jl#L1-L43">source</a></div></details></article><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>The simplest reconstruction requires only k-space data:</p><pre><code class="language-julia hljs">using MriReconstructionToolbox

# Create k-space data
ksp = rand(ComplexF32, 128, 128, 8)
acq = AcquisitionInfo(ksp; is3D=false)

# Direct reconstruction (adjoint of encoding operator)
x_direct = reconstruct(acq)
println(&quot;Reconstructed image size: &quot;, size(x_direct))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constructing encoding operator: 125.23 ¬µs (2.1 M allocations: 2.002 MiB)
Reconstructing image: 1.63 ms (1.05 M allocations: 1.000 MiB)
Computing scaling factor: 48.52 ms (2.49 M allocations: 2.379 MiB, 84.17% compilation time)
Total time: 264.89 ms
Reconstructed image size: (128, 128, 8)</code></pre><h2 id="Reconstruction-Workflow"><a class="docs-heading-anchor" href="#Reconstruction-Workflow">Reconstruction Workflow</a><a id="Reconstruction-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstruction-Workflow" title="Permalink"></a></h2><h3 id="1.-Direct-Reconstruction-(No-Regularization)"><a class="docs-heading-anchor" href="#1.-Direct-Reconstruction-(No-Regularization)">1. Direct Reconstruction (No Regularization)</a><a id="1.-Direct-Reconstruction-(No-Regularization)-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Direct-Reconstruction-(No-Regularization)" title="Permalink"></a></h3><p>When no regularization is specified, <code>reconstruct</code> performs a direct reconstruction using the adjoint of the encoding operator:</p><pre><code class="language-julia hljs"># Fully sampled data
ksp_full = rand(ComplexF32, 64, 64, 4)
smaps = rand(ComplexF32, 64, 64, 4)
acq_full = AcquisitionInfo(ksp_full; is3D=false, sensitivity_maps=smaps)

# Direct reconstruction: x = ùíú&#39; * y
x_direct = reconstruct(acq_full)
println(&quot;Direct reconstruction completed&quot;)
println(&quot;Output type: &quot;, typeof(x_direct))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Constructing encoding operator: 148.5 ms (19.04 M allocations: 18.155 MiB, 99.7% compilation time)
Reconstructing image: 118.32 ¬µs (32.9 k allocations: 32.133 KiB)
Computing scaling factor: 39.72 ms (1.32 M allocations: 1.258 MiB, 99.5% compilation time)
Total time: 353.64 ms
Direct reconstruction completed
Output type: Matrix{ComplexF32}</code></pre><p>This is equivalent to:</p><p class="math-container">\[\hat{x} = \mathcal{A}^H y\]</p><p>where <span>$\mathcal{A}$</span> is the encoding operator and <span>$y$</span> is the k-space data.</p><h3 id="2.-Iterative-Reconstruction-with-Regularization"><a class="docs-heading-anchor" href="#2.-Iterative-Reconstruction-with-Regularization">2. Iterative Reconstruction with Regularization</a><a id="2.-Iterative-Reconstruction-with-Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Iterative-Reconstruction-with-Regularization" title="Permalink"></a></h3><p>For undersampled data, add regularization to solve:</p><p class="math-container">\[\min_x \frac{1}{2}\|\mathcal{A}x - y\|_2^2 + \sum_i \lambda_i R_i(x)\]</p><pre><code class="language-julia hljs"># Undersampled acquisition
mask = rand(Bool, 64, 64)
mask[25:40, 25:40] .= true  # Fully sample center
acq_under = AcquisitionInfo(
    nothing;
    is3D=false,
    image_size=(64, 64),
    subsampling=mask,
    sensitivity_maps=smaps
)

# Simulate undersampled data
phantom = rand(ComplexF32, 64, 64)
data = simulate_acquisition(phantom, acq_under)

# Reconstruct with L2 regularization
x_tikhonov = reconstruct(data, Tikhonov(0.01); maxit=20, verbose=false)
println(&quot;Tikhonov reconstruction completed&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Tikhonov reconstruction completed</code></pre><h2 id="Configuration-Control"><a class="docs-heading-anchor" href="#Configuration-Control">Configuration Control</a><a id="Configuration-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration-Control" title="Permalink"></a></h2><p>The <code>Config</code> struct centralizes reconstruction parameters. You can pass configuration either as a <code>Config</code> object or as keyword arguments. It can make easy to pass common options together, while still allowing overrides via keywords.</p><pre><code class="language-julia hljs"># Method 1: Keyword arguments
x1 = reconstruct(data; maxit=50, tol=1e-5, verbose=false)</code></pre><pre><code class="language-julia hljs"># Method 2: Config object
config = Config(maxit=50, tol=1e-5, verbose=false)
x2 = reconstruct(data; config=config)</code></pre><pre><code class="language-julia hljs"># Method 3: Override config fields with keywords
config_base = Config(maxit=100, verbose=false)
x3 = reconstruct(data; config=config_base, maxit=25, verbose=false)  # Uses maxit=25</code></pre><h3 id="Important-Configuration-Options"><a class="docs-heading-anchor" href="#Important-Configuration-Options">Important Configuration Options</a><a id="Important-Configuration-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Important-Configuration-Options" title="Permalink"></a></h3><h4 id="Iteration-Control"><a class="docs-heading-anchor" href="#Iteration-Control">Iteration Control</a><a id="Iteration-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration-Control" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Basic iteration parameters
Config(
    maxit=100,     # Maximum iterations
    tol=1e-4,      # Stopping tolerance
    freq=10,       # Print progress every 10 iterations
    verbose=true   # Enable logging
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Config(BartScaling(), 0.0001, 100, 10, true, false, false, nothing, false, false, false, false, println)</code></pre><h4 id="Performance-Options"><a class="docs-heading-anchor" href="#Performance-Options">Performance Options</a><a id="Performance-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Options" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Threading and performance
Config(
    threaded=true,                          # Enable multi-threading
    exact_opnorm=false,                     # Fast operator norm estimation
    disable_problem_decomposition=false,    # Enable automatic decomposition
    disable_operator_normalization=false    # Enable operator normalization
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Config(BartScaling(), 0.0001, 100, nothing, true, true, false, nothing, false, false, false, false, println)</code></pre><h4 id="Normalization"><a class="docs-heading-anchor" href="#Normalization">Normalization</a><a id="Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Normalization" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.NoScaling"><a class="docstring-binding" href="#MriReconstructionToolbox.NoScaling"><code>MriReconstructionToolbox.NoScaling</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">NoScaling() &lt;: Normalization</code></pre><p>A normalization strategy that applies no scaling to the data.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/scaling.jl#L3-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.BartScaling"><a class="docstring-binding" href="#MriReconstructionToolbox.BartScaling"><code>MriReconstructionToolbox.BartScaling</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">BartScaling() &lt;: Normalization</code></pre><p>A normalization strategy that mimics the scaling used in BART. This approach inspects the distribution of the absolute values of the initial guess <code>x‚ÇÄ</code> (obtained as the adjoint of the encoding operator applied to the measured k-space data) and selects either the 90th percentile or the maximum value, depending on the spread of the values. If the difference between the maximum and the 90th percentile is less than twice the difference between the 90th percentile and the median, the 90th percentile is used; otherwise, the maximum value is used. This helps to avoid scaling based on outliers in the data.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/scaling.jl#L10-L20">source</a></div></details></article><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.MeasurementBasedScaling"><a class="docstring-binding" href="#MriReconstructionToolbox.MeasurementBasedScaling"><code>MriReconstructionToolbox.MeasurementBasedScaling</code></a> ‚Äî <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">MeasurementBasedScaling() &lt;: Normalization</code></pre><p>A normalization strategy that scales the data based on the average absolute value of the k-space measurements. This approach mimic the normalization of MeasurementBasedNormalization from RegularizedLeastSquares.jl (which is used by MRIReco.jl).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/scaling.jl#L23-L29">source</a></div></details></article><pre><code class="language-julia hljs"># Data scaling strategies
config_bart = Config(normalization=BartScaling())
config_none = Config(normalization=NoScaling())</code></pre><h2 id="Algorithm-Selection"><a class="docs-heading-anchor" href="#Algorithm-Selection">Algorithm Selection</a><a id="Algorithm-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Selection" title="Permalink"></a></h2><p>Choose optimization algorithms based on your problem:</p><pre><code class="language-julia hljs"># Single algorithm
x_cg = reconstruct(data, Tikhonov(0.01), FISTA(); maxit=30, verbose=false)</code></pre><pre><code class="language-julia hljs"># Tuple of algorithms (tries in order until convergence)
x_auto = reconstruct(
    data,
    Tikhonov(0.01),
    (CG(), FISTA(), ADMM());
    maxit=50,
    verbose=false
)</code></pre><p>Common algorithms:</p><ul><li><strong>CG</strong>: Conjugate Gradient - best for quadratic problems (Tikhonov regularization)</li><li><strong>FISTA</strong>: Fast Iterative Shrinkage-Thresholding - for L1 regularization</li><li><strong>ADMM</strong>: Alternating Direction Method of Multipliers - for composite regularization</li></ul><p>See <a href="../algorithms/">Optimization Algorithms</a> for detailed information.</p><h2 id="Multiple-Regularization-Terms"><a class="docs-heading-anchor" href="#Multiple-Regularization-Terms">Multiple Regularization Terms</a><a id="Multiple-Regularization-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Regularization-Terms" title="Permalink"></a></h2><p>Combine multiple regularization terms for advanced reconstruction:</p><pre><code class="language-julia hljs"># Wavelet sparsity + Total Variation
x_composite = reconstruct(
    data,
    (L1Wavelet2D(0.005), TotalVariation2D(0.002));
    maxit=50,
    verbose=false
)</code></pre><p>See <a href="../regularization/">Regularization</a> for available regularization methods.</p><h2 id="Initial-Guess"><a class="docs-heading-anchor" href="#Initial-Guess">Initial Guess</a><a id="Initial-Guess-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Guess" title="Permalink"></a></h2><p>Provide a custom initial estimate:</p><pre><code class="language-julia hljs"># Use direct reconstruction as initial guess
x_init = reconstruct(data; verbose=false)

# Refine with regularization
x_refined = reconstruct(
    data,
    L1Wavelet2D(0.005);
    x‚ÇÄ=x_init,
    maxit=30,
    verbose=false
)</code></pre><h2 id="Advanced-Features"><a class="docs-heading-anchor" href="#Advanced-Features">Advanced Features</a><a id="Advanced-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Features" title="Permalink"></a></h2><h3 id="Operator-Normalization"><a class="docs-heading-anchor" href="#Operator-Normalization">Operator Normalization</a><a id="Operator-Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-Normalization" title="Permalink"></a></h3><p>By default, the encoding operator is normalized for better convergence:</p><pre><code class="language-julia hljs"># Standard (normalized operator)
x_norm = reconstruct(data, Tikhonov(0.01); maxit=20, verbose=false)

# Disable normalization
x_unnorm = reconstruct(
    data,
    Tikhonov(0.01);
    disable_operator_normalization=true,
    maxit=20,
    verbose=false
)
println(&quot;Both reconstructions completed&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Both reconstructions completed</code></pre><p>Operator normalization typically improves convergence by ensuring the encoding operator has unit norm, which helps algorithms choose better stepsizes.</p><h3 id="Normal-Operator-Optimization"><a class="docs-heading-anchor" href="#Normal-Operator-Optimization">Normal Operator Optimization</a><a id="Normal-Operator-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-Operator-Optimization" title="Permalink"></a></h3><p>For least-squares problems, <code>reconstruct</code> can exploit efficient normal operator implementations:</p><pre><code class="language-julia hljs"># Standard optimization (enabled by default)
config_opt = Config(disable_normalop_optimization=false)

# Disable for debugging
config_noopt = Config(disable_normalop_optimization=true)</code></pre><p>When enabled, instead of computing <span>$\|\mathcal{A}x - y\|_2^2$</span> directly, it computes <span>$\|\mathcal{A}^H\mathcal{A}x - \mathcal{A}^Hy\|_2^2$</span>, which can be more efficient when <span>$\mathcal{A}^H\mathcal{A}$</span> has an optimized implementation.</p><h3 id="Output-Scaling"><a class="docs-heading-anchor" href="#Output-Scaling">Output Scaling</a><a id="Output-Scaling-1"></a><a class="docs-heading-anchor-permalink" href="#Output-Scaling" title="Permalink"></a></h3><p>Control whether the output is scaled back to the original data range:</p><pre><code class="language-julia hljs"># Standard (output is inverse-scaled)
x_scaled = reconstruct(data, Tikhonov(0.01); maxit=20, verbose=false)

# Keep scaled output
x_unscaled = reconstruct(
    data,
    Tikhonov(0.01);
    disable_inverse_scale_output=true,
    maxit=20,
    verbose=false
)

println(&quot;Scaled max: &quot;, maximum(abs, x_scaled))
println(&quot;Unscaled max: &quot;, maximum(abs, x_unscaled))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scaled max: 2.9813325
Unscaled max: 0.53622854</code></pre><h2 id="Problem-Decomposition"><a class="docs-heading-anchor" href="#Problem-Decomposition">Problem Decomposition</a><a id="Problem-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Decomposition" title="Permalink"></a></h2><p>For multi-dimensional data (e.g., 2D+time, multi-slice), <code>reconstruct</code> automatically decomposes the problem over independent dimensions:</p><pre><code class="language-julia hljs"># Multi-slice 2D data
nx, ny, nslices, nc = 32, 32, 5, 4
ksp_ms = rand(ComplexF32, nx, ny, nc, nslices)
smaps_ms = rand(ComplexF32, nx, ny, nc, nslices)

acq_ms = AcquisitionInfo(ksp_ms; is3D=false, sensitivity_maps=smaps_ms)

# Automatically decomposes over slice dimension
x_slices = reconstruct(acq_ms; maxit=10, verbose=false)
println(&quot;Reconstructed slices: &quot;, size(x_slices))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Reconstructed slices: (32, 32, 5)</code></pre><p>The decomposition:</p><ul><li>Identifies batch dimensions not affected by Fourier transforms or regularization</li><li>Reconstructs each batch element independently</li><li>Utilizes multiple CPU cores for parallel execution</li><li>Combines results into a single output array</li></ul><p>To disable decomposition (e.g., for debugging):</p><pre><code class="language-julia hljs">x_no_decomp = reconstruct(
    acq_ms;
    disable_problem_decomposition=true,
    maxit=10,
    verbose=false
)
println(&quot;Sequential reconstruction completed&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Sequential reconstruction completed</code></pre><p>See <a href="../decomposition/">Problem Decomposition</a> for details.</p><h2 id="Custom-Progress-Logging"><a class="docs-heading-anchor" href="#Custom-Progress-Logging">Custom Progress Logging</a><a id="Custom-Progress-Logging-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Progress-Logging" title="Permalink"></a></h2><p>Replace the default logging function:</p><pre><code class="language-julia hljs"># Custom print function
messages = String[]
custom_print(args...) = push!(messages, string(args...))

config_custom = Config(
    printfunc=custom_print,
    verbose=true
)

x_custom = reconstruct(data, Tikhonov(0.01); config=config_custom, maxit=5)
println(&quot;Captured &quot;, length(messages), &quot; log messages&quot;)
println(&quot;First message: &quot;, messages[1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Captured 17 log messages
First message: Constructing encoding operator: 237.27 ¬µs (1.06 M allocations: 1.010 MiB)</code></pre><h2 id="Named-Dimensions-Support"><a class="docs-heading-anchor" href="#Named-Dimensions-Support">Named Dimensions Support</a><a id="Named-Dimensions-Support-1"></a><a class="docs-heading-anchor-permalink" href="#Named-Dimensions-Support" title="Permalink"></a></h2><p><code>reconstruct</code> preserves <code>NamedDimsArray</code> metadata:</p><pre><code class="language-julia hljs">using NamedDims

# Create named k-space data
ksp_named = NamedDimsArray{(:kx, :ky, :coil)}(
    rand(ComplexF32, 64, 64, 4)
)
smaps_named = NamedDimsArray{(:x, :y, :coil)}(
    rand(ComplexF32, 64, 64, 4)
)

acq_named = AcquisitionInfo(ksp_named; sensitivity_maps=smaps_named)
x_named = reconstruct(acq_named; verbose=false)

println(&quot;Output dimensions: &quot;, dimnames(x_named))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Output dimensions: (:x, :y)</code></pre><p>See <a href="../nameddims/">Named Dimensions</a> for more information.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simulation/">¬´ Simulation Tools</a><a class="docs-footer-nextpage" href="../regularization/">Regularization ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Tuesday 18 November 2025 23:46">Tuesday 18 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
