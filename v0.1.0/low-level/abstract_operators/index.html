<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AbstractOperators.jl ¬∑ MriReconstructionToolbox.jl</title><meta name="title" content="AbstractOperators.jl ¬∑ MriReconstructionToolbox.jl"/><meta property="og:title" content="AbstractOperators.jl ¬∑ MriReconstructionToolbox.jl"/><meta property="twitter:title" content="AbstractOperators.jl ¬∑ MriReconstructionToolbox.jl"/><meta name="description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="og:description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="twitter:description" content="Documentation for MriReconstructionToolbox.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="MriReconstructionToolbox.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="MriReconstructionToolbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MriReconstructionToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../theory/">Theoretical Background</a></li><li><span class="tocitem">High-level Interface</span><ul><li><a class="tocitem" href="../../high-level/acquisition_info/">AcquisitionInfo</a></li><li><a class="tocitem" href="../../high-level/simulation/">Simulation Tools</a></li><li><a class="tocitem" href="../../high-level/reconstruction/">Reconstruction</a></li><li><a class="tocitem" href="../../high-level/regularization/">Regularization</a></li><li><a class="tocitem" href="../../high-level/algorithms/">Optimization Algorithms</a></li><li><a class="tocitem" href="../../high-level/nameddims/">Named Dimensions</a></li><li><a class="tocitem" href="../../high-level/decomposition/">Problem Decomposition</a></li></ul></li><li><span class="tocitem">Low-Level Interface</span><ul><li><a class="tocitem" href="../operators/">MRI Operators</a></li><li><a class="tocitem" href="../custom_reconstruction/">Custom Reconstruction</a></li><li class="is-active"><a class="tocitem" href>AbstractOperators.jl</a><ul class="internal"><li><a class="tocitem" href="#Why-Matrix-Free-Operators?"><span>Why Matrix-Free Operators?</span></a></li><li><a class="tocitem" href="#Introducing-AbstractOperators.jl"><span>Introducing AbstractOperators.jl</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Creating-Custom-Operators"><span>Creating Custom Operators</span></a></li><li><a class="tocitem" href="#Operators-in-AbstractOperators.jl"><span>Operators in AbstractOperators.jl</span></a></li><li><a class="tocitem" href="#Integration-with-MriReconstructionToolbox"><span>Integration with MriReconstructionToolbox</span></a></li><li><a class="tocitem" href="#Further-Reading"><span>Further Reading</span></a></li></ul></li><li><a class="tocitem" href="../proximal_operators/">ProximalOperators.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Low-Level Interface</a></li><li class="is-active"><a href>AbstractOperators.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AbstractOperators.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/master/docs/src/low-level/abstract_operators.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="abstract_operators"><a class="docs-heading-anchor" href="#abstract_operators">AbstractOperators.jl: Matrix-Free Linear Operators</a><a id="abstract_operators-1"></a><a class="docs-heading-anchor-permalink" href="#abstract_operators" title="Permalink"></a></h1><h2 id="Why-Matrix-Free-Operators?"><a class="docs-heading-anchor" href="#Why-Matrix-Free-Operators?">Why Matrix-Free Operators?</a><a id="Why-Matrix-Free-Operators?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Matrix-Free-Operators?" title="Permalink"></a></h2><h3 id="The-Matrix-Representation-Problem"><a class="docs-heading-anchor" href="#The-Matrix-Representation-Problem">The Matrix Representation Problem</a><a id="The-Matrix-Representation-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Matrix-Representation-Problem" title="Permalink"></a></h3><p>In image processing and MRI reconstruction, operators are typically linear maps that can be theoretically represented as matrices. For example:</p><ul><li><strong>Fourier Transform</strong>: <span>$\mathcal{F}: \mathbb{C}^{N \times M} \to \mathbb{C}^{N \times M}$</span></li><li><strong>Subsampling</strong>: <span>$\Gamma: \mathbb{C}^{N \times M} \to \mathbb{C}^{K}$</span> (where <span>$K &lt; N \times M$</span>)</li><li><strong>Sensitivity Encoding</strong>: <span>$\mathcal{S}: \mathbb{C}^{N \times M} \to \mathbb{C}^{N \times M \times N_c}$</span></li></ul><p>In traditional linear algebra, these would be represented as matrices <span>$A$</span> where:</p><p class="math-container">\[y = A x\]</p><p>where <span>$x$</span> is the <strong>flattened</strong> input image and <span>$y$</span> is the flattened output.</p><h3 id="The-Good:-Rich-Algorithm-Ecosystem"><a class="docs-heading-anchor" href="#The-Good:-Rich-Algorithm-Ecosystem">The Good: Rich Algorithm Ecosystem</a><a id="The-Good:-Rich-Algorithm-Ecosystem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Good:-Rich-Algorithm-Ecosystem" title="Permalink"></a></h3><p>Matrix representations have significant advantages:</p><p>‚úÖ <strong>Wide range of algorithms</strong>: Conjugate Gradient, LSQR, GMRES, and many other iterative solvers work with matrices.</p><p>‚úÖ <strong>Theoretical foundation</strong>: Linear algebra theory provides convergence guarantees, preconditioning strategies, and optimality conditions.</p><p>‚úÖ <strong>Composability</strong>: Operators can be easily composed (<span>$C = A \cdot B$</span>), added (<span>$D = A + B$</span>), scaled, transposed, etc.</p><p>‚úÖ <strong>Standard interface</strong>: Most numerical libraries understand matrices.</p><h3 id="The-Bad:-Computational-Inefficiency"><a class="docs-heading-anchor" href="#The-Bad:-Computational-Inefficiency">The Bad: Computational Inefficiency</a><a id="The-Bad:-Computational-Inefficiency-1"></a><a class="docs-heading-anchor-permalink" href="#The-Bad:-Computational-Inefficiency" title="Permalink"></a></h3><p>However, explicit matrix representations have critical drawbacks for image processing:</p><p>‚ùå <strong>Memory explosion</strong>: An <span>$N \times M$</span> image treated as a vector of length <span>$N \cdot M$</span> requires a matrix of size <span>$(N \cdot M) \times (N \cdot M)$</span> to represent an operator.</p><p><strong>Example</strong>: For a modest <span>$256 \times 256$</span> image:</p><ul><li>Flattened vector: <span>$256 \times 256 = 65{,}536$</span> elements</li><li>Matrix representation: <span>$65{,}536 \times 65{,}536 = 4{,}294{,}967{,}296$</span> elements</li><li>Memory (Float64): ~34 GB just for <strong>one</strong> operator!</li></ul><p>‚ùå <strong>Loss of structure</strong>: Flattening an image discards its natural 2D/3D structure, making many operations less efficient.</p><p>‚ùå <strong>Slow operations</strong>: Matrix-vector multiplication is <span>$\mathcal{O}(N^2)$</span>, while FFT on structured data is <span>$\mathcal{O}(N \log N)$</span>.</p><h3 id="The-Solution:-Matrix-Free-Operators"><a class="docs-heading-anchor" href="#The-Solution:-Matrix-Free-Operators">The Solution: Matrix-Free Operators</a><a id="The-Solution:-Matrix-Free-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#The-Solution:-Matrix-Free-Operators" title="Permalink"></a></h3><p><strong>Matrix-free operators</strong> are objects that:</p><ul><li>Act like matrices (support <code>*</code>, <code>&#39;</code>, composition, addition)  </li><li>Work directly on multi-dimensional arrays (no flattening needed)  </li><li>Implement efficient algorithms internally (FFT, convolution, sparse indexing)  </li><li>Use minimal memory (store only parameters, not full matrix)</li></ul><p>This is exactly what <a href="https://github.com/kul-forbes/AbstractOperators.jl">AbstractOperators.jl</a> provides.</p><h2 id="Introducing-AbstractOperators.jl"><a class="docs-heading-anchor" href="#Introducing-AbstractOperators.jl">Introducing AbstractOperators.jl</a><a id="Introducing-AbstractOperators.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Introducing-AbstractOperators.jl" title="Permalink"></a></h2><p><a href="https://github.com/kul-forbes/AbstractOperators.jl">AbstractOperators.jl</a> is a Julia package that provides a comprehensive framework for matrix-free linear operators with:</p><ul><li><strong>Rich operator library</strong>: Fourier transforms, convolutions, finite differences, wavelets, and more</li><li><strong>Matrix-like interface</strong>: Supports <code>*</code>, <code>&#39;</code>, <code>+</code>, <code>‚àò</code>, and composition</li><li><strong>Multi-dimensional arrays</strong>: Works directly on images without flattening</li><li><strong>Performance optimizations</strong>: Multi-threading, SIMD, operator fusion</li><li><strong>Extensibility</strong>: Easy to define custom operators</li></ul><h3 id="Key-Features"><a class="docs-heading-anchor" href="#Key-Features">Key Features</a><a id="Key-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Features" title="Permalink"></a></h3><table><tr><th style="text-align: right">Feature</th><th style="text-align: right">Benefit</th></tr><tr><td style="text-align: right"><strong>Matrix-free</strong></td><td style="text-align: right">Minimal memory footprint</td></tr><tr><td style="text-align: right"><strong>Lazy composition</strong></td><td style="text-align: right">Combines operators without intermediate allocations</td></tr><tr><td style="text-align: right"><strong>Multi-threading</strong></td><td style="text-align: right">Automatic parallelization where supported</td></tr><tr><td style="text-align: right"><strong>Type stability</strong></td><td style="text-align: right">Full Julia type inference for performance</td></tr></table><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><p>Note: Code blocks below are illustrative and not executed during docs build. To run them locally, activate a Julia environment and install the required packages:</p><pre><code class="language-julia hljs">using Pkg

# Add the package from GitHub
Pkg.add(url=&quot;https://github.com/hakkelt/AbstractOperators.jl&quot;)
Pkg.add(url=&quot;https://github.com/hakkelt/AbstractOperators.jl&quot;, subdir=&quot;FFTWOperators&quot;)
Pkg.add(url=&quot;https://github.com/hakkelt/AbstractOperators.jl&quot;, subdir=&quot;WaveletOperators&quot;)</code></pre><h3 id="Simple-Operator-Example"><a class="docs-heading-anchor" href="#Simple-Operator-Example">Simple Operator Example</a><a id="Simple-Operator-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Operator-Example" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using AbstractOperators, FFTW, FFTWOperators, LinearAlgebra</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nx, ny = 64, 64</code><code class="nohighlight hljs ansi" style="display:block;">(64, 64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; F = ‚Ñ± = DFT(ComplexF32, (nx, ny)) # A 2D DFT operator for 64x64 images</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñ±  ‚ÑÇ^(64, 64) -&gt; ‚ÑÇ^(64, 64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = randn(ComplexF32, nx, ny);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = ‚Ñ± * x;  # Apply forward transform</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y == fft(x)  # Verify correctness</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x_back = F&#39; * y;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x_back == bfft(x)  # Verify correctness</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; scale = 1 / (nx * ny) # Normalization factor that makes F unitary</code><code class="nohighlight hljs ansi" style="display:block;">0.000244140625</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; norm(x - scale * x_back) / norm(x) &lt; 1e-6 # Verify it&#39;s an approximate inverse</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="Operator-Composition"><a class="docs-heading-anchor" href="#Operator-Composition">Operator Composition</a><a id="Operator-Composition-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-Composition" title="Permalink"></a></h3><p>Operators can be composed naturally:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mask = rand(Bool, nx, ny); mask[32-5:32+5, 32-5:32+5] .= true;  # Fully sample center</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(mask) # Count of sampled points</code><code class="nohighlight hljs ansi" style="display:block;">2135</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Œì = GetIndex(zeros(ComplexF32, nx, ny), (mask,))</code><code class="nohighlight hljs ansi" style="display:block;">‚Üì  ‚ÑÇ^(64, 64) -&gt; ‚ÑÇ^2135</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñ±_sub = Œì * ‚Ñ± # Compose: subsampled Fourier transform</code><code class="nohighlight hljs ansi" style="display:block;">‚Üì*‚Ñ±  ‚ÑÇ^(64, 64) -&gt; ‚ÑÇ^2135</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = randn(ComplexF32, nx, ny);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = ‚Ñ±_sub * x; # Apply the composition</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y == fft(x)[mask]  # Verify correctness</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="Operator-Algebra"><a class="docs-heading-anchor" href="#Operator-Algebra">Operator Algebra</a><a id="Operator-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-Algebra" title="Permalink"></a></h3><p>AbstractOperators supports rich algebraic operations:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; I_op = Eye(ComplexF32, (nx, ny)) # Identity operator</code><code class="nohighlight hljs ansi" style="display:block;">I  ‚ÑÇ^(64, 64) -&gt; ‚ÑÇ^(64, 64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = 2 * ‚Ñ± # Scaling</code><code class="nohighlight hljs ansi" style="display:block;">Œ±‚Ñ±  ‚ÑÇ^(64, 64) -&gt; ‚ÑÇ^(64, 64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = A + I_op # Addition of outputs</code><code class="nohighlight hljs ansi" style="display:block;">Œ±‚Ñ±+I  ‚ÑÇ^(64, 64) -&gt; ‚ÑÇ^(64, 64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = randn(ComplexF32, nx, ny);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = DiagOp(d) # Diagonal scaling, i.e., element-wise multiplication with d</code><code class="nohighlight hljs ansi" style="display:block;">‚ï≤  ‚ÑÇ^(64, 64) -&gt; ‚ÑÇ^(64, 64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = D * B  # Composition / chaining of operators</code><code class="nohighlight hljs ansi" style="display:block;">‚ï≤*‚Ñ±+‚ï≤  ‚ÑÇ^(64, 64) -&gt; ‚ÑÇ^(64, 64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = randn(ComplexF32, nx, ny);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = C * x; # Apply composed operator</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y == d .* (2 * fft(x) + x)  # Verify correctness</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><h3 id="Batch-Operations"><a class="docs-heading-anchor" href="#Batch-Operations">Batch Operations</a><a id="Batch-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-Operations" title="Permalink"></a></h3><p>Operators can work on batched inputs (e.g., multi-coil data):</p><pre><code class="language-julia hljs"># Sensitivity map operator (per-coil scaling)
nc = 8  # 8 coils
smaps = randn(ComplexF32, nx, ny, nc)
ùíÆ = DiagOp(smaps)

# Encoding operator: sensitivity * FFT
ùíú = ‚Ñ± * ùíÆ

# Apply to multi-coil image
x = randn(ComplexF32, nx, ny, nc)
ksp = ùíú * x
println(&quot;Image size: $(size(x)), k-space size: $(size(ksp))&quot;)</code></pre><h2 id="Creating-Custom-Operators"><a class="docs-heading-anchor" href="#Creating-Custom-Operators">Creating Custom Operators</a><a id="Creating-Custom-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Custom-Operators" title="Permalink"></a></h2><p>You can easily define custom operators for domain-specific operations. Here&#39;s a minimal example:</p><pre><code class="language-julia hljs">using AbstractOperators

# Define the operator struct
struct MyCustomLinOp{N,M,D,C} &lt;: LinearOperator
    dim_in::NTuple{M,Int}
    dim_out::NTuple{N,Int}
    # Add any additional fields needed for your operator
end

# Mandatory functions

# 1. size: Return (codomain_size, domain_size)
Base.size(L::MyCustomLinOp) = (L.dim_out, L.dim_in)

# 2. domain_type: Return the element type of the input
AbstractOperators.domain_type(::MyCustomLinOp{N,M,D,C}) where {N,M,D,C} = D

# 3. codomain_type: Return the element type of the output
AbstractOperators.codomain_type(::MyCustomLinOp{N,M,D,C}) where {N,M,D,C} = C

# 4. fun_name: Return a string/symbol for display purposes
AbstractOperators.fun_name(::MyCustomLinOp) = &quot;MyOp&quot;

# 5. mul!: Forward operator (output, operator, input)
function LinearAlgebra.mul!(y::AbstractArray, L::MyCustomLinOp, x::AbstractArray)
    # Utility function to check if
    #   - eltype(x) == domain_type(L)
    #   - eltype(y) == codomain_type(L)
    #   - size(x) == size(L, 2)
    #   - size(y) == size(L, 1)
    #   - x isa domain_storage_type(L)
    #   - y isa codomain_storage_type(L)
    AbstractOperators.check(y, L, x)
    # Implement your forward operation here
    # Example: y .= some_function(x)
    return y
end

# 6. mul! for adjoint: Adjoint operator (output, adjoint_operator, input)
function LinearAlgebra.mul!(y::AbstractArray, L::AdjointOperator{&lt;:MyCustomLinOp}, x::AbstractArray)
    AbstractOperators.check(y, L, x) # Utility function to check types and sizes
    # Implement your adjoint operation here
    # Example: y .= adjoint_function(x)
    return y
end</code></pre><p><strong>Key points for custom operators:</strong></p><ol><li><strong>Inherit from the right type</strong>: <code>LinearOperator</code> for linear maps, <code>AbstractOperator</code> for nonlinear</li><li><strong>Implement required interface</strong>: <code>size</code>, <code>domain_type</code>, <code>codomain_type</code>, <code>fun_name</code>, <code>mul!</code></li><li><strong>Implement adjoint</strong>: For <code>LinearOperator</code>, also implement <code>mul!</code> for <code>AdjointOperator</code></li><li><strong>Test correctness</strong>: Verify <code>‚ü®Lx, y‚ü© = ‚ü®x, L&#39;y‚ü©</code> for random inputs</li></ol><p>For complete details on implementing custom operators, see the <a href="https://hakkelt.github.io/AbstractOperators.jl/stable/custom/">AbstractOperators.jl documentation</a>.</p><h2 id="Operators-in-AbstractOperators.jl"><a class="docs-heading-anchor" href="#Operators-in-AbstractOperators.jl">Operators in AbstractOperators.jl</a><a id="Operators-in-AbstractOperators.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-in-AbstractOperators.jl" title="Permalink"></a></h2><p>AbstractOperators.jl provides a rich library of pre-built operators, from which many are directly useful in MRI reconstruction:</p><h3 id="Transform-Operators"><a class="docs-heading-anchor" href="#Transform-Operators">Transform Operators</a><a id="Transform-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Transform-Operators" title="Permalink"></a></h3><ul><li><strong><code>DFT</code></strong>: Discrete Fourier Transform (via FFTWOperators.jl)</li><li><strong><code>DCT</code></strong>: Discrete Cosine Transform (via FFTWOperators.jl)</li><li><strong><code>RDFT</code></strong>: Real-to-complex FFT (via FFTWOperators.jl)</li><li><strong><code>WaveletOp</code></strong>: Wavelet transforms (via WaveletOperators.jl)</li><li><strong><code>NFFTOp</code></strong>: Non-uniform FFT (via NFFTOperators.jl)</li></ul><h3 id="Linear-Operators"><a class="docs-heading-anchor" href="#Linear-Operators">Linear Operators</a><a id="Linear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Operators" title="Permalink"></a></h3><ul><li><strong><code>Eye</code></strong>: Identity operator</li><li><strong><code>DiagOp</code></strong>: Diagonal operator (element-wise multiplication)</li><li><strong><code>MatrixOp</code></strong>: Wraps a regular matrix</li><li><strong><code>FiniteDiff</code></strong>: Finite difference (gradients)</li><li><strong><code>Variation</code></strong>: Total variation operator</li><li><strong><code>GetIndex</code></strong>: Subsampling/indexing operator</li><li><strong><code>ZeroPad</code></strong>: Zero-padding operator</li></ul><h3 id="Calculus"><a class="docs-heading-anchor" href="#Calculus">Calculus</a><a id="Calculus-1"></a><a class="docs-heading-anchor-permalink" href="#Calculus" title="Permalink"></a></h3><ul><li><strong><code>Scale</code></strong>: Scalar multiplication</li><li><strong><code>Compose</code></strong>: Operator composition</li><li><strong><code>Sum</code></strong>: Sum outputs of different operators applying to the same input</li><li><strong><code>BroadCast</code></strong>: Broadcasting operator ‚Äì repeats the output of an operator across specified dimensions</li><li><strong><code>Reshape</code></strong>: Reshape arrays</li></ul><h3 id="Nonlinear-Operators"><a class="docs-heading-anchor" href="#Nonlinear-Operators">Nonlinear Operators</a><a id="Nonlinear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Operators" title="Permalink"></a></h3><ul><li><strong><code>Sigmoid</code></strong>, <strong><code>Tanh</code></strong>, <strong><code>Exp</code></strong>, <strong><code>Sin</code></strong>, <strong><code>Cos</code></strong>: Activation functions</li><li><strong><code>SoftMax</code></strong>, <strong><code>SoftPlus</code></strong>: Softmax and softplus</li></ul><h3 id="Signal-Processing"><a class="docs-heading-anchor" href="#Signal-Processing">Signal Processing</a><a id="Signal-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-Processing" title="Permalink"></a></h3><ul><li><strong><code>Conv</code></strong>: Convolution (via DSPOperators.jl)</li><li><strong><code>Filt</code></strong>: Filtering (via DSPOperators.jl)</li><li><strong><code>Xcorr</code></strong>: Cross-correlation (via DSPOperators.jl)</li></ul><h2 id="Integration-with-MriReconstructionToolbox"><a class="docs-heading-anchor" href="#Integration-with-MriReconstructionToolbox">Integration with MriReconstructionToolbox</a><a id="Integration-with-MriReconstructionToolbox-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-MriReconstructionToolbox" title="Permalink"></a></h2><p>MriReconstructionToolbox.jl is built entirely on AbstractOperators.jl. All encoding operators (<code>get_encoding_operator</code>, <code>get_fourier_operator</code>, etc.) return AbstractOperators objects, giving you:</p><ul><li><strong>Seamless integration</strong>: Use operators with any algorithm that supports the interface</li><li><strong>Flexibility</strong>: Extract and manipulate individual components of the encoding chain</li><li><strong>Performance</strong>: Benefit from all AbstractOperators optimizations</li><li><strong>Easy debugging</strong>: Inspect and visualize operators at any stage</li><li><strong>Extensibility</strong>: Add custom operators to the reconstruction pipeline</li></ul><h3 id="Extracting-Operators"><a class="docs-heading-anchor" href="#Extracting-Operators">Extracting Operators</a><a id="Extracting-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-Operators" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Get the full encoding operator
ùíú = get_encoding_operator(acq_info)

# Or get individual components
‚Ñ± = get_fourier_operator(acq_info)
ùíÆ = get_sensitivity_map_operator(acq_info)
‚Ñ≥ = get_subsampling_operator(acq_info)

# Manually compose them
ùíú_manual = ‚Ñ≥ * ‚Ñ± * ùíÆ

# Both are equivalent
@assert ùíú * x ‚âà ùíú_manual * x</code></pre><h3 id="Custom-Reconstruction-Pipeline"><a class="docs-heading-anchor" href="#Custom-Reconstruction-Pipeline">Custom Reconstruction Pipeline</a><a id="Custom-Reconstruction-Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Reconstruction-Pipeline" title="Permalink"></a></h3><pre><code class="language-julia hljs">ùíÆ = MyCustomSensitivityMapOperator(...)
‚Ñ± = get_fourier_operator(acq_info)
‚Ñ≥ = get_subsampling_operator(acq_info)
ùíú = ‚Ñ≥ * ‚Ñ± * ùíÆ

# Add custom regularization operator
ùí≤ = MyCustomWavelet(...)  # Your custom operator

# Build optimization problem
using StructuredOptimization
v = Variable(ùíú&#39; * ksp)  # Initial guess

# Solve custom problem
xÃÇ, _ = @minimize ls(ùíú * v - ksp) + 0.01 * norm(ùí≤ * v, 1)</code></pre><h2 id="Further-Reading"><a class="docs-heading-anchor" href="#Further-Reading">Further Reading</a><a id="Further-Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Reading" title="Permalink"></a></h2><ul><li><strong>AbstractOperators.jl Documentation</strong>: <a href="https://hakkelt.github.io/AbstractOperators.jl/stable/">https://hakkelt.github.io/AbstractOperators.jl/stable/</a></li><li><strong>Custom Operators Guide</strong>: <a href="https://hakkelt.github.io/AbstractOperators.jl/stable/custom/">https://hakkelt.github.io/AbstractOperators.jl/stable/custom/</a></li><li><strong>Operator Properties</strong>: Learn about <a href="https://hakkelt.github.io/AbstractOperators.jl/stable/properties/">operator traits and properties</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../custom_reconstruction/">¬´ Custom Reconstruction</a><a class="docs-footer-nextpage" href="../proximal_operators/">ProximalOperators.jl ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Tuesday 18 November 2025 23:46">Tuesday 18 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
