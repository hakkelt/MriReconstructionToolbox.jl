<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MRI Operators · MriReconstructionToolbox.jl</title><meta name="title" content="MRI Operators · MriReconstructionToolbox.jl"/><meta property="og:title" content="MRI Operators · MriReconstructionToolbox.jl"/><meta property="twitter:title" content="MRI Operators · MriReconstructionToolbox.jl"/><meta name="description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="og:description" content="Documentation for MriReconstructionToolbox.jl."/><meta property="twitter:description" content="Documentation for MriReconstructionToolbox.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.svg" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="MriReconstructionToolbox.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="MriReconstructionToolbox.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MriReconstructionToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../theory/">Theoretical Background</a></li><li><span class="tocitem">High-level Interface</span><ul><li><a class="tocitem" href="../../high-level/acquisition_info/">AcquisitionInfo</a></li><li><a class="tocitem" href="../../high-level/simulation/">Simulation Tools</a></li><li><a class="tocitem" href="../../high-level/reconstruction/">Reconstruction</a></li><li><a class="tocitem" href="../../high-level/regularization/">Regularization</a></li><li><a class="tocitem" href="../../high-level/algorithms/">Optimization Algorithms</a></li><li><a class="tocitem" href="../../high-level/nameddims/">Named Dimensions</a></li><li><a class="tocitem" href="../../high-level/decomposition/">Problem Decomposition</a></li></ul></li><li><span class="tocitem">Low-Level Interface</span><ul><li class="is-active"><a class="tocitem" href>MRI Operators</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li><li><a class="tocitem" href="#Encoding-Operators"><span>Encoding Operators</span></a></li><li><a class="tocitem" href="#Fourier-Operators"><span>Fourier Operators</span></a></li><li><a class="tocitem" href="#Sensitivity-Map-Operators"><span>Sensitivity Map Operators</span></a></li><li><a class="tocitem" href="#Subsampling-Operators"><span>Subsampling Operators</span></a></li><li><a class="tocitem" href="#Integration-with-AcquisitionInfo"><span>Integration with AcquisitionInfo</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li><li><a class="tocitem" href="../custom_reconstruction/">Custom Reconstruction</a></li><li><a class="tocitem" href="../abstract_operators/">AbstractOperators.jl</a></li><li><a class="tocitem" href="../proximal_operators/">ProximalOperators.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Low-Level Interface</a></li><li class="is-active"><a href>MRI Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MRI Operators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/master/docs/src/low-level/operators.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MRI-Operators"><a class="docs-heading-anchor" href="#MRI-Operators">MRI Operators</a><a id="MRI-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#MRI-Operators" title="Permalink"></a></h1><p>This page documents the low-level operator interface for MRI reconstruction. These operators model the physical MRI encoding process and its components: Fourier transforms, coil sensitivity maps, and k-space subsampling patterns.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The MRI encoding operator <span>$\mathcal{A}$</span> maps an image to k-space measurements:</p><p class="math-container">\[y = \mathcal{A} x = \Gamma \mathcal{F} S x\]</p><p>where:</p><ul><li><code>S</code>: Sensitivity map operator (coil sensitivities)</li><li><code>ℱ</code>: Fourier transform operator</li><li><code>Γ</code>: Subsampling operator (k-space sampling pattern)</li><li><code>x</code>: Image (single-coil)</li><li><code>y</code>: Acquired k-space data (multi-coil, potentially undersampled)</li></ul><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.get_encoding_operator"><a class="docstring-binding" href="#MriReconstructionToolbox.get_encoding_operator"><code>MriReconstructionToolbox.get_encoding_operator</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">get_encoding_operator(info::AcquisitionInfo; threaded::Bool=true, fast_planning::Bool=false)
get_encoding_operator(ksp, is3D::Bool; sensitivity_maps=nothing, image_size=nothing, subsampling=nothing, threaded=true, fast_planning=false)
get_encoding_operator(ksp::NamedDimsArray; sensitivity_maps=nothing, image_size=nothing, subsampling=nothing, threaded=true, fast_planning=false)</code></pre><p>Create the main MRI encoding operator for data acquisition modeling.</p><p><strong>Arguments for AcquisitionInfo method</strong></p><ul><li><code>info::AcquisitionInfo</code>: Contains k-space data, sensitivity maps, image size, subsampling pattern, and other acquisition parameters.</li></ul><p><strong>Arguments for raw k-space method</strong></p><ul><li><code>ksp</code>: K-space data array</li><li><code>is3D::Bool</code>: Whether the acquisition is 3D</li><li><code>sensitivity_maps</code>: Coil sensitivity maps (optional)</li><li><code>image_size</code>: Image size tuple (optional)</li><li><code>subsampling</code>: Subsampling pattern (optional)</li></ul><p><strong>Arguments for NamedDimsArray method</strong></p><ul><li><code>ksp::NamedDimsArray</code>: K-space data with named dimensions</li><li><code>sensitivity_maps</code>: Coil sensitivity maps (optional, can be NamedDimsArray)</li><li><code>image_size</code>: Image size tuple (optional, Tuple{Int,Int} or Tuple{Int,Int,Int})</li><li><code>subsampling</code>: Subsampling pattern (optional, 2D or 3D pattern)</li></ul><p><strong>Common keyword arguments</strong></p><ul><li><code>threaded::Bool=true</code>: Whether to use multi-threading for operator construction and FFTs.</li><li><code>fast_planning::Bool=false</code>: Whether to use fast FFTW planning (reduces setup time, may affect performance).</li></ul><p><strong>Returns</strong></p><ul><li>Encoding operator modeling the full MRI acquisition process, including Fourier transform, sensitivity map encoding, and subsampling (if present).</li></ul><p><strong>Details</strong></p><p>This function constructs the composite encoding operator E that models the MRI data acquisition pipeline:</p><ol><li>Applies sensitivity map encoding (if provided)</li><li>Applies Fourier transform (subsampled if a subsampling pattern is present)</li><li>Returns the composed operator E = F * S or E = F</li></ol><p>If no sensitivity maps are provided, only the Fourier/subsampled Fourier operator is returned.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/encoding/encoding_operators.jl#L9-L46">source</a></div></details></article><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.get_fourier_operator"><a class="docstring-binding" href="#MriReconstructionToolbox.get_fourier_operator"><code>MriReconstructionToolbox.get_fourier_operator</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">get_fourier_operator(ksp, [is3D], [shifted_kspace_dims], [shifted_image_dims]; threaded=true, fast_planning=false)
get_fourier_operator(info::AcquisitionInfo; threaded=true, fast_planning=false)</code></pre><p>Create a Fourier transform operator for MRI data.</p><p>The operator transforms between image space and k-space using the discrete Fourier transform. For named dimension arrays, automatically detects 2D vs 3D from dimension names. For regular arrays, specify <code>is3D</code> explicitly.</p><p><strong>Arguments with explicit types</strong></p><ul><li><code>ksp</code>: K-space data array (NamedDimsArray or AbstractArray)</li><li><code>is3D::Bool</code>: Whether the data is 3D (required for AbstractArray; optionally auto-detected for NamedDimsArray)</li><li><code>shifted_kspace_dims::Tuple</code>: Dimensions in k-space where the DC is at the first index instead of the center (useful for pre-shifted data, default: empty)</li><li><code>shifted_image_dims::Tuple</code>: Dimensions in image space requiring fftshift (equivalent to an kspace-domain sign-alternation, default: empty)</li><li><code>threaded::Bool</code>: Whether to use multi-threading for FFT operations (default: true)</li><li><code>fast_planning::Bool</code>: If true, use FFTW.ESTIMATE for faster planning (default: false)</li></ul><p><strong>Returns</strong></p><ul><li>Fourier transform operator</li></ul><p><strong>Method Variants</strong></p><ul><li><strong>NamedDimsArray</strong>: Automatically determines 2D vs 3D from the presence of <code>:kz</code> dimension</li><li><strong>AbstractArray</strong>: Requires explicit <code>is3D</code> parameter to determine dimensionality</li><li><strong>AcquisitionInfo</strong>: Extracts <code>ksp</code>, <code>is3D</code>, <code>shifted_kspace_dims</code>, and <code>shifted_image_dims</code> from the <code>AcquisitionInfo</code> struct</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/encoding/fourier_operators.jl#L8-L33">source</a></div></details></article><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.get_sensitivity_map_operator"><a class="docstring-binding" href="#MriReconstructionToolbox.get_sensitivity_map_operator"><code>MriReconstructionToolbox.get_sensitivity_map_operator</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">get_sensitivity_map_operator(sensitivity_maps, [is3D]; batch_dims=nothing, threaded=true)</code></pre><p>Create a sensitivity map operator for parallel MRI reconstruction.</p><p><strong>Arguments</strong></p><ul><li><code>sensitivity_maps</code>: Sensitivity maps for each coil (NamedDimsArray or AbstractArray)</li><li><code>is3D::Bool</code>: Whether the sensitivity maps are 3D (required for AbstractArray; auto-detected for NamedDimsArray)</li><li><code>batch_dims</code>: Batch dimensions specification (NamedTuple for NamedDimsArray, Tuple for AbstractArray, optional)</li><li><code>threaded::Bool=true</code>: Whether to use multi-threading for operations</li></ul><p><strong>Returns</strong></p><ul><li>Sensitivity map operator (NamedDimsOp for NamedDimsArray inputs, Compose for AbstractArray inputs)</li></ul><p><strong>Method Variants</strong></p><ul><li><strong>NamedDimsArray</strong>: Automatically detects 2D vs 3D from dimension names, uses NamedTuple for batch_dims</li><li><strong>AbstractArray</strong>: Requires explicit <code>is3D</code> parameter, uses Tuple for batch_dims</li></ul><p><strong>Required dimension names (NamedDimsArray method)</strong></p><ul><li><code>:x</code>: First spatial dimension (required, must be first dimension)</li><li><code>:y</code>: Second spatial dimension (required, must be second dimension)</li><li><code>:z</code>: Third spatial dimension (optional, must be third dimension if present)</li><li><code>:coil</code>: Coil dimension (required, must be last dimension)</li></ul><p><strong>Array shapes (AbstractArray method)</strong></p><ul><li><strong>2D</strong>: <code>(nx, ny, ncoils)</code> or <code>(nx, ny, ncoils, batch_dims...)</code></li><li><strong>3D</strong>: <code>(nx, ny, nz, ncoils)</code> or <code>(nx, ny, nz, ncoils, batch_dims...)</code></li></ul><p><strong>Details</strong></p><p>The operator multiplies single-coil images by the sensitivity maps to produce multi-coil images. The adjoint operation combines multi-coil images using the conjugate of the sensitivity maps.</p><p>Forward operation: <code>multi_coil_images = S * single_coil_image</code> Adjoint operation: <code>combined_image = S&#39; * multi_coil_images</code></p><p>The operator is constructed as:</p><ol><li><code>DiagOp(sensitivity_maps)</code>: Element-wise multiplication with sensitivity maps</li><li><code>BroadCast(Eye(dummy_img), size(sensitivity_maps))</code>: Broadcasting identity for image dimensions</li><li><code>BatchOp(...)</code>: If batch dimensions are present, wrap in batch operator</li></ol><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/encoding/sensitivity_map_operators.jl#L9-L49">source</a></div></details></article><article><details class="docstring" open="true"><summary id="MriReconstructionToolbox.get_subsampling_operator"><a class="docstring-binding" href="#MriReconstructionToolbox.get_subsampling_operator"><code>MriReconstructionToolbox.get_subsampling_operator</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">get_subsampling_operator(subsampled_ksp, img_size, subsampling)
get_subsampling_operator(info::AcquisitionInfo)</code></pre><p>Create the subsampling operator Γ that maps full k-space to a given subsampled layout. This is useful when you need Γ separately or want to compose it with other operators manually. For a combined <code>Γ * ℱ</code> operator, use <code>get_subsampled_fourier_operator</code>.</p><p><strong>Arguments</strong></p><ul><li><code>subsampled_ksp</code>: Subsampled k-space array (Array or NamedDimsArray). Used to determine batch dimensions and, for named arrays, validate dimension names.</li><li><code>img_size</code>: Full image size as <code>(nx, ny)</code> or <code>(nx, ny, nz)</code>.</li><li><code>subsampling</code>: Subsampling pattern that produced <code>subsampled_ksp</code>. Supports boolean masks and tuples mixing <code>Colon</code>, boolean masks, and ranges.</li><li><code>info::AcquisitionInfo</code>: Alternative API that takes configuration from a validated <code>AcquisitionInfo</code> (must contain <code>image_size</code> and <code>subsampling</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Γ</code>: A <code>GetIndex</code> or <code>BatchOp{GetIndex}</code>. For NamedDims inputs, a <code>NamedDimsOp</code> wrapping the un-named Γ is returned to preserve dimension names.</li></ul><p><strong>Details</strong></p><ul><li>For NamedDims input, validates that <code>dimnames(subsampled_ksp)</code> matches the names implied by the subsampling pattern and the full k-space layout.</li><li>Batch dimensions (beyond the spatial dims) are preserved; Γ becomes a batch operator when needed.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MriReconstructionToolbox

# 2D mask, array input
ksp_full = rand(ComplexF32, 64, 64, 8)
mask = rand(Bool, 64, 64)
ksp_sub = ksp_full[mask, :]
Γ = get_subsampling_operator(ksp_sub, (64, 64), mask)

# 2D NamedDims input
using NamedDims
ksp_nd = NamedDimsArray{(:kxy, :coil)}(ksp_sub)
Γ_nd = get_subsampling_operator(ksp_nd, (64, 64), mask)

# Via AcquisitionInfo
info = AcquisitionInfo(ksp_sub; is3D=false, image_size=(64, 64), subsampling=mask)
Γ_info = get_subsampling_operator(info)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/MriReconstructionToolbox.jl/blob/9f05f0badc341253f4d58725d7af3069095010ce/src/encoding/subsampling_operators.jl#L61-L110">source</a></div></details></article><h2 id="Encoding-Operators"><a class="docs-heading-anchor" href="#Encoding-Operators">Encoding Operators</a><a id="Encoding-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Encoding-Operators" title="Permalink"></a></h2><p>The encoding operator is the primary interface for creating complete MRI forward models.</p><h3 id="Usage-Patterns"><a class="docs-heading-anchor" href="#Usage-Patterns">Usage Patterns</a><a id="Usage-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-Patterns" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MriReconstructionToolbox

# Single-coil, fully sampled
ksp = rand(ComplexF32, 64, 64)
get_encoding_operator(ksp, false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ℱ*±  ℂ^(64, 64) -&gt; ℂ^(64, 64) </code></pre><pre><code class="language-julia hljs"># Multi-coil parallel imaging
ksp_mc = rand(ComplexF32, 64, 64, 8)
sensitivity_maps = coil_sensitivities(64, 64, 8)
get_encoding_operator(ksp_mc, false; sensitivity_maps=sensitivity_maps)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Π  ℂ^(64, 64) -&gt; ℂ^(64, 64, 8) </code></pre><pre><code class="language-julia hljs"># Undersampled reconstruction
mask = rand(Bool, 64, 64)
mask[28:36, 28:36] .= true  # Fully sample center
ksp_sub = rand(ComplexF32, sum(mask), 8)

get_encoding_operator(
    ksp_sub, false;
    sensitivity_maps=sensitivity_maps,
    image_size=(64, 64),
    subsampling=mask
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Π  ℂ^(64, 64) -&gt; ℂ^(2060, 8) </code></pre><h3 id="With-Named-Dimensions"><a class="docs-heading-anchor" href="#With-Named-Dimensions">With Named Dimensions</a><a id="With-Named-Dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#With-Named-Dimensions" title="Permalink"></a></h3><pre><code class="language-julia hljs">using NamedDims

ksp_named = NamedDimsArray{(:kx, :ky, :coil)}(rand(ComplexF32, 64, 64, 8))
smaps_named = NamedDimsArray{(:x, :y, :coil)}(coil_sensitivities(64, 64, 8))

get_encoding_operator(ksp_named; sensitivity_maps=smaps_named)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Π  ℂ^(64, 64) -&gt; ℂ^(64, 64, 8) </code></pre><h3 id="Keyword-Arguments"><a class="docs-heading-anchor" href="#Keyword-Arguments">Keyword Arguments</a><a id="Keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-Arguments" title="Permalink"></a></h3><p>All encoding operator methods support:</p><ul><li><code>sensitivity_maps=nothing</code>: Sensitivity maps for parallel imaging</li><li><code>image_size=nothing</code>: Image size (required for subsampled reconstruction)</li><li><code>subsampling=nothing</code>: Subsampling pattern</li><li><code>threaded::Bool=true</code>: Enable multi-threading</li><li><code>fast_planning::Bool=false</code>: Use fast FFTW planning</li></ul><h2 id="Fourier-Operators"><a class="docs-heading-anchor" href="#Fourier-Operators">Fourier Operators</a><a id="Fourier-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-Operators" title="Permalink"></a></h2><p>Fourier operators implement the discrete Fourier transform between image space and k-space.</p><h3 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h3><p><strong>Forward transform (image → k-space):</strong></p><p class="math-container">\[k(u,v) = \sum_{x=0}^{N_x-1} \sum_{y=0}^{N_y-1} I(x,y) e^{-2\pi i (ux/N_x + vy/N_y)}\]</p><p><strong>Inverse transform (k-space → image):</strong></p><p class="math-container">\[I(x,y) = \frac{1}{N_x N_y} \sum_{u=0}^{N_x-1} \sum_{v=0}^{N_y-1} k(u,v) e^{2\pi i (ux/N_x + vy/N_y)}\]</p><h3 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h3><pre><code class="language-julia hljs"># 2D Fourier transform
img = rand(ComplexF32, 64, 64)
F = get_fourier_operator(img, false)  # false = 2D

ksp_fft = F * img        # Forward FFT
img_recon = F&#39; * ksp_fft # Inverse FFT</code></pre><pre><code class="language-julia hljs"># 3D Fourier transform
img_3d = rand(ComplexF32, 64, 64, 32)
F_3d = get_fourier_operator(img_3d, true)  # true = 3D</code></pre><pre><code class="language-julia hljs"># Multi-coil data (FFT applied per coil)
ksp_multi = rand(ComplexF32, 64, 64, 8)
F_multi = get_fourier_operator(ksp_multi, false)
img_multi = F_multi&#39; * ksp_multi  # Shape: (64, 64, 8)</code></pre><h3 id="Dimension-Name-Mappings"><a class="docs-heading-anchor" href="#Dimension-Name-Mappings">Dimension Name Mappings</a><a id="Dimension-Name-Mappings-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension-Name-Mappings" title="Permalink"></a></h3><p>When using <code>NamedDimsArray</code>, dimension names are automatically mapped:</p><p>| Image Space | K-space | |––––––-|––––-|| | <code>:x</code>        | <code>:kx</code>   | | <code>:y</code>        | <code>:ky</code>   | | <code>:z</code>        | <code>:kz</code>   |</p><pre><code class="language-julia hljs"># Create k-space data with proper dimension names
ksp_named = NamedDimsArray{(:kx, :ky)}(rand(ComplexF32, 64, 64))
F_named = get_fourier_operator(ksp_named, false)

# The operator preserves dimension names during inverse FFT
img_named = F_named&#39; * ksp_named
println(&quot;K-space dimensions: &quot;, dimnames(ksp_named))
println(&quot;Image dimensions: &quot;, dimnames(img_named))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">K-space dimensions: (:kx, :ky)
Image dimensions: (:x, :y)</code></pre><h3 id="Implementation-Details"><a class="docs-heading-anchor" href="#Implementation-Details">Implementation Details</a><a id="Implementation-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Details" title="Permalink"></a></h3><ul><li><strong>FFTW Integration</strong>: Uses FFTW.jl for high-performance computation<ul><li><code>FFTW.MEASURE</code> (default): Optimal performance with longer planning</li><li><code>FFTW.ESTIMATE</code>: Faster planning with potentially slower execution</li></ul></li><li><strong>Multi-threading</strong>: Automatically uses all available threads when <code>threaded=true</code></li><li><strong>Dimension Handling</strong>: <ul><li>2D: FFT along dimensions (1, 2)</li><li>3D: FFT along dimensions (1, 2, 3)</li><li>Batch dimensions (coils, time) are preserved</li></ul></li></ul><h2 id="Sensitivity-Map-Operators"><a class="docs-heading-anchor" href="#Sensitivity-Map-Operators">Sensitivity Map Operators</a><a id="Sensitivity-Map-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Sensitivity-Map-Operators" title="Permalink"></a></h2><p>Sensitivity map operators model the spatial sensitivity profiles of receiver coils in parallel MRI.</p><h3 id="Mathematical-Formulation"><a class="docs-heading-anchor" href="#Mathematical-Formulation">Mathematical Formulation</a><a id="Mathematical-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Formulation" title="Permalink"></a></h3><p><strong>Forward operation</strong> (single-coil → multi-coil):</p><p class="math-container">\[(S x)_c = s_c \odot x\]</p><p><strong>Adjoint operation</strong> (multi-coil → single-coil):</p><p class="math-container">\[S^H y = \sum_{c=1}^{N_c} \bar{s}_c \odot y_c\]</p><p>where <span>$s_c$</span> is the sensitivity map for coil <span>$c$</span>, <span>$\odot$</span> denotes element-wise multiplication, and <span>$N_c$</span> is the number of coils.</p><h3 id="Basic-Usage-2"><a class="docs-heading-anchor" href="#Basic-Usage-2">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-2" title="Permalink"></a></h3><pre><code class="language-julia hljs"># 2D multi-coil sensitivity maps
nx, ny, nc = 64, 64, 8
smaps = coil_sensitivities(nx, ny, nc)
S = get_sensitivity_map_operator(smaps, false)

# Forward: single-coil → multi-coil
img_single = rand(ComplexF32, nx, ny)
multi_coil = S * img_single
println(&quot;Multi-coil size: &quot;, size(multi_coil))  # (64, 64, 8)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Multi-coil size: (64, 64, 8)</code></pre><pre><code class="language-julia hljs"># Adjoint: multi-coil → combined image
img_combined = S&#39; * multi_coil
println(&quot;Combined size: &quot;, size(img_combined))  # (64, 64)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Combined size: (64, 64)</code></pre><h3 id="3D-Sensitivity-Maps"><a class="docs-heading-anchor" href="#3D-Sensitivity-Maps">3D Sensitivity Maps</a><a id="3D-Sensitivity-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Sensitivity-Maps" title="Permalink"></a></h3><pre><code class="language-julia hljs"># 3D sensitivity maps
nx, ny, nz, nc = 64, 64, 32, 8
smaps_3d = coil_sensitivities(nx, ny, nz, nc)
S_3d = get_sensitivity_map_operator(smaps_3d, true)

img_3d = rand(ComplexF32, nx, ny, nz)
multi_coil_3d = S_3d * img_3d
println(&quot;3D multi-coil size: &quot;, size(multi_coil_3d))  # (64, 64, 32, 8)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3D multi-coil size: (64, 64, 32, 8)</code></pre><h3 id="Multi-Slice-with-Per-Slice-Sensitivity-Maps"><a class="docs-heading-anchor" href="#Multi-Slice-with-Per-Slice-Sensitivity-Maps">Multi-Slice with Per-Slice Sensitivity Maps</a><a id="Multi-Slice-with-Per-Slice-Sensitivity-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Slice-with-Per-Slice-Sensitivity-Maps" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Per-slice sensitivity maps
nx, ny, nc, nz = 64, 64, 8, 20
smaps_per_slice = repeat(coil_sensitivities(nx, ny, nc), outer=(1, 1, 1, nz))

S_multislice = get_sensitivity_map_operator(smaps_per_slice, false)

img_slices = rand(ComplexF32, nx, ny, nz)
multi_coil_slices = S_multislice * img_slices
println(&quot;Multi-slice coil size: &quot;, size(multi_coil_slices))  # (64, 64, 8, 20)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Multi-slice coil size: (64, 64, 8, 20)</code></pre><h3 id="Batch-Dimensions-(Dynamic-Imaging)"><a class="docs-heading-anchor" href="#Batch-Dimensions-(Dynamic-Imaging)">Batch Dimensions (Dynamic Imaging)</a><a id="Batch-Dimensions-(Dynamic-Imaging)-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-Dimensions-(Dynamic-Imaging)" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Sensitivity maps for dynamic imaging
nx, ny, nc, nt = 64, 64, 8, 30  # 30 time frames
smaps_dyn = coil_sensitivities(nx, ny, nc)

S_dynamic = get_sensitivity_map_operator(
    smaps_dyn, false;
    batch_dims=(nt,)
)

img_dynamic = rand(ComplexF32, nx, ny, nt)
multi_coil_dynamic = S_dynamic * img_dynamic
println(&quot;Dynamic multi-coil size: &quot;, size(multi_coil_dynamic))  # (64, 64, 8, 30)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dynamic multi-coil size: (64, 64, 8, 30)</code></pre><h3 id="Required-Array-Shapes"><a class="docs-heading-anchor" href="#Required-Array-Shapes">Required Array Shapes</a><a id="Required-Array-Shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Required-Array-Shapes" title="Permalink"></a></h3><p><strong>2D Sensitivity Maps:</strong></p><ul><li>Single slice: <code>(nx, ny, ncoils)</code></li><li>Multi-slice: <code>(nx, ny, ncoils, nslices)</code></li></ul><p><strong>3D Sensitivity Maps:</strong></p><ul><li>Standard: <code>(nx, ny, nz, ncoils)</code></li></ul><p><strong>NamedDims Requirements:</strong></p><ul><li>Must include <code>:x</code>, <code>:y</code> (and <code>:z</code> for 3D)</li><li>Must have <code>:coil</code> as the last spatial dimension</li><li>Dimension order: <code>:x</code>, <code>:y</code>, [<code>:z</code>], <code>:coil</code></li></ul><h3 id="Physical-Interpretation"><a class="docs-heading-anchor" href="#Physical-Interpretation">Physical Interpretation</a><a id="Physical-Interpretation-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-Interpretation" title="Permalink"></a></h3><p>The adjoint operation <span>$S^H$</span> performs optimal coil combination:</p><p class="math-container">\[x_{\text{combined}} = S^H y = \sum_{c=1}^{N_c} \bar{s}_c \odot y_c\]</p><p>This weighted combination assigns higher weights to regions where each coil has stronger sensitivity, accounting for spatial response and phase variations.</p><h2 id="Subsampling-Operators"><a class="docs-heading-anchor" href="#Subsampling-Operators">Subsampling Operators</a><a id="Subsampling-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Subsampling-Operators" title="Permalink"></a></h2><p>Subsampling operators model undersampled k-space acquisition patterns for accelerated MRI.</p><h3 id="Mathematical-Formulation-2"><a class="docs-heading-anchor" href="#Mathematical-Formulation-2">Mathematical Formulation</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Formulation-2" title="Permalink"></a></h3><p><strong>Forward operation</strong> (extract sampled locations):</p><p class="math-container">\[y = \Gamma x\]</p><p><strong>Adjoint operation</strong> (zero-fill unsampled locations):</p><p class="math-container">\[\Gamma^H y = \text{zero-filled full k-space}\]</p><p>The adjoint places acquired data at sampled locations and zeros elsewhere.</p><h3 id="Subsampling-Pattern-Types"><a class="docs-heading-anchor" href="#Subsampling-Pattern-Types">Subsampling Pattern Types</a><a id="Subsampling-Pattern-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Subsampling-Pattern-Types" title="Permalink"></a></h3><h4 id="2D-Patterns"><a class="docs-heading-anchor" href="#2D-Patterns">2D Patterns</a><a id="2D-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Patterns" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Boolean mask
mask_bool = rand(Bool, 64, 64)
mask_bool[30:35, 30:35] .= true  # Fully sample center
println(&quot;Acceleration: &quot;, round(64*64/sum(mask_bool), digits=2), &quot;x&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Acceleration: 2.06x</code></pre><pre><code class="language-julia hljs"># Linear indices
indices_linear = [1, 10, 50, 100, 500, 1000]</code></pre><pre><code class="language-julia hljs"># Cartesian indices
cart_indices = [CartesianIndex(i, j) for i in 1:64 for j in 1:64 if rand() &lt; 0.3]</code></pre><pre><code class="language-julia hljs"># Separable pattern (independent per dimension)
pattern_x = 1:2:64        # Every other line
pattern_y = rand(Bool, 64)  # Random sampling
pattern_sep = (pattern_x, pattern_y)</code></pre><h4 id="3D-Patterns"><a class="docs-heading-anchor" href="#3D-Patterns">3D Patterns</a><a id="3D-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Patterns" title="Permalink"></a></h4><pre><code class="language-julia hljs"># 3D boolean mask
mask_3d = rand(Bool, 64, 64, 32)
mask_3d[30:35, 30:35, 14:18] .= true</code></pre><pre><code class="language-julia hljs"># Separable 3D
pattern_3d = (1:64, rand(Bool, 64), 1:2:32)  # (x: all, y: random, z: every other)</code></pre><pre><code class="language-julia hljs"># Hybrid 2D+1D (common for 3D Cartesian)
mask_2d = rand(Bool, 64, 64)
pattern_kz = 1:2:32
pattern_hybrid = (mask_2d, pattern_kz)</code></pre><h3 id="Basic-Usage-3"><a class="docs-heading-anchor" href="#Basic-Usage-3">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-3" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Create undersampling pattern
nx, ny = 64, 64
mask = rand(Bool, nx, ny)
mask[30:35, 30:35] .= true

# Subsample k-space (use tuple pattern)
ksp_full = rand(ComplexF32, nx, ny, 8)
indices = findall(mask)
ksp_sub = ksp_full[indices, :]

# Create subsampling operator with tuple pattern
Γ = get_subsampling_operator(ksp_sub, (nx, ny), (mask,))

# Zero-fill reconstruction
ksp_zerofilled = Γ&#39; * ksp_sub
println(&quot;Zero-filled size: &quot;, size(ksp_zerofilled))  # (64, 64, 8)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Zero-filled size: (64, 64, 8)</code></pre><h3 id="Combined-Operations"><a class="docs-heading-anchor" href="#Combined-Operations">Combined Operations</a><a id="Combined-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Combined-Operations" title="Permalink"></a></h3><p>For complete encoding including Fourier and subsampling, use <code>get_encoding_operator</code>:</p><pre><code class="language-julia hljs"># Complete encoding operator: Image → Subsampled k-space
img_size = (64, 64)
smaps_enc = coil_sensitivities(64, 64, 8)
E_complete = get_encoding_operator(
    ksp_sub, false;
    sensitivity_maps=smaps_enc,
    image_size=img_size,
    subsampling=(mask,)
)

# Direct operations
img = rand(ComplexF32, 64, 64)
ksp_acquired = E_complete * img        # Forward
img_recon = E_complete&#39; * ksp_acquired # Adjoint</code></pre><h3 id="Multi-Slice-2D-Subsampling"><a class="docs-heading-anchor" href="#Multi-Slice-2D-Subsampling">Multi-Slice 2D Subsampling</a><a id="Multi-Slice-2D-Subsampling-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Slice-2D-Subsampling" title="Permalink"></a></h3><pre><code class="language-julia hljs"># For multi-slice data, the encoding operator handles it automatically
nx, ny, nz = 64, 64, 20
mask_2d = rand(Bool, nx, ny)
indices_2d = findall(mask_2d)

# Each slice uses the same subsampling pattern
ksp_full_ms = rand(ComplexF32, nx, ny, 8, nz)
ksp_sub_ms = similar(ksp_full_ms, sum(mask_2d), 8, nz)
for iz in 1:nz
    ksp_sub_ms[:, :, iz] = ksp_full_ms[indices_2d, :, iz]
end

println(&quot;Multi-slice subsampled size: &quot;, size(ksp_sub_ms))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Multi-slice subsampled size: (2056, 8, 20)</code></pre><h3 id="Supported-Pattern-Formats"><a class="docs-heading-anchor" href="#Supported-Pattern-Formats">Supported Pattern Formats</a><a id="Supported-Pattern-Formats-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-Pattern-Formats" title="Permalink"></a></h3><p><strong>2D Patterns:</strong></p><table><tr><th style="text-align: right">Format</th><th style="text-align: right">Example</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right">Boolean 2D</td><td style="text-align: right"><code>mask::Array{Bool,2}</code></td><td style="text-align: right">Arbitrary 2D sampling</td></tr><tr><td style="text-align: right">Linear indices</td><td style="text-align: right"><code>indices::Vector{Int}</code></td><td style="text-align: right">Flattened k-space indices</td></tr><tr><td style="text-align: right">Cartesian indices</td><td style="text-align: right"><code>indices::Vector{CartesianIndex{2}}</code></td><td style="text-align: right">2D coordinates</td></tr><tr><td style="text-align: right">Separable</td><td style="text-align: right"><code>(pattern_x, pattern_y)</code></td><td style="text-align: right">Independent per dimension</td></tr></table><p><strong>3D Patterns:</strong></p><table><tr><th style="text-align: right">Format</th><th style="text-align: right">Example</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right">Boolean 3D</td><td style="text-align: right"><code>mask::Array{Bool,3}</code></td><td style="text-align: right">Arbitrary 3D sampling</td></tr><tr><td style="text-align: right">Separable</td><td style="text-align: right"><code>(pattern_x, pattern_y, pattern_z)</code></td><td style="text-align: right">Independent per dimension</td></tr><tr><td style="text-align: right">Hybrid 1D+2D</td><td style="text-align: right"><code>(pattern_x, mask_yz)</code></td><td style="text-align: right">1D pattern + 2D mask</td></tr><tr><td style="text-align: right">Hybrid 2D+1D</td><td style="text-align: right"><code>(mask_2d, pattern_z)</code></td><td style="text-align: right">2D mask + 1D pattern</td></tr></table><h3 id="Acceleration-Factor"><a class="docs-heading-anchor" href="#Acceleration-Factor">Acceleration Factor</a><a id="Acceleration-Factor-1"></a><a class="docs-heading-anchor-permalink" href="#Acceleration-Factor" title="Permalink"></a></h3><p>The acceleration factor <span>$R$</span> quantifies undersampling:</p><pre><code class="language-julia hljs">mask = rand(Bool, 128, 128)
full_samples = 128 * 128
acquired_samples = sum(mask)
acceleration = full_samples / acquired_samples
println(&quot;Acceleration factor: &quot;, round(acceleration, digits=2), &quot;x&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Acceleration factor: 2.0x</code></pre><p><strong>Typical ranges:</strong></p><ul><li>Cartesian 2D: R = 2-6</li><li>Cartesian 3D: R = 3-10</li><li>Radial/Spiral: R = 4-12</li><li>Random: R = 2-8</li></ul><p>Higher acceleration requires stronger regularization for good reconstruction quality.</p><h2 id="Integration-with-AcquisitionInfo"><a class="docs-heading-anchor" href="#Integration-with-AcquisitionInfo">Integration with AcquisitionInfo</a><a id="Integration-with-AcquisitionInfo-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-AcquisitionInfo" title="Permalink"></a></h2><p>Extract operators directly from <code>AcquisitionInfo</code>:</p><pre><code class="language-julia hljs"># Create acquisition info
mask_acq = rand(Bool, 64, 64)
indices_acq = findall(mask_acq)
ksp_sub_acq = rand(ComplexF32, sum(mask_acq), 8)
smaps_acq = coil_sensitivities(64, 64, 8)

acq_info = AcquisitionInfo(
    ksp_sub_acq;
    is3D=false,
    image_size=(64, 64),
    subsampling=(mask_acq,),
    sensitivity_maps=smaps_acq
)

# Extract operators
E = get_encoding_operator(acq_info)
S = get_sensitivity_map_operator(acq_info)
Γ = get_subsampling_operator(acq_info)

println(&quot;Encoding operator type: &quot;, typeof(E))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Encoding operator type: Compose{4, 3, Tuple{AbstractOperators.NoOperatorBroadCast{ComplexF32, 2, 3, false, Array{ComplexF32}}, DiagOp{3, ComplexF32, ComplexF32, Array{ComplexF32}, Array{ComplexF32}, Array{ComplexF32, 3}, static(false)}, DFT{3, ComplexF32, ComplexF32, (1, 2), Array, FFTW.cFFTWPlan{ComplexF32, -1, false, 3, Tuple{Int64, Int64}}, FFTW.cFFTWPlan{ComplexF32, 1, false, 3, Tuple{Int64, Int64}}, Float32}, AbstractOperators.SimpleBatchOpSingleThreaded{ComplexF32, ComplexF32, (false, false, true), (false, true), GetIndex{Tuple{Matrix{Bool}}, 1, 2, ComplexF32, Array{ComplexF32}}, 3, 2, 1}}, Tuple{Array{ComplexF32, 3}, Array{ComplexF32, 3}, Array{ComplexF32, 3}}}</code></pre><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><ul><li><a href="../../high-level/acquisition_info/">AcquisitionInfo</a> - High-level configuration</li><li><a href="../../high-level/reconstruction/">Reconstruction</a> - Using operators in reconstruction</li><li><a href="../../high-level/simulation/">Simulation Tools</a> - Generate test data and patterns</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../high-level/decomposition/">« Problem Decomposition</a><a class="docs-footer-nextpage" href="../custom_reconstruction/">Custom Reconstruction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Tuesday 18 November 2025 23:46">Tuesday 18 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
